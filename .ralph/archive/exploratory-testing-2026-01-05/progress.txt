################################################################################
#                     EXPLORATORY TESTING PROGRESS LOG                         #
#                         meal-planner-demo                                    #
################################################################################

Started: 2026-01-05T00:00:00+00:00

Tests to complete: 42
Tests completed: 18
Tests passing: 10
Tests failing: 8

================================================================================
Test: AUTH-001 - Email/password signup flow creates account successfully
Date: 2026-01-05T12:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/auth/signup/page.tsx - Multi-step signup form with tier selection, details, and payment steps
- apps/web/src/app/api/auth/signup/route.ts - API endpoint for user creation with validation and session
- apps/web/src/app/api/auth/signup/schema.ts - Zod validation schema for signup input
- apps/web/src/server/auth/config.ts - NextAuth configuration with credentials provider
- apps/web/src/app/auth/_components/CelebrationModal.tsx - Success modal with redirect to dashboard
- apps/web/prisma/schema.prisma - User and Password models confirmed

Code Issues Found:
- None identified - implementation is solid

API Tests (if applicable):
- POST /api/auth/signup - Validates input, hashes password with argon2id, creates user, auto-signs in
- Duplicate email returns 409 "User already exists"
- Invalid input returns 400 with field-level validation errors

Observations:
- Password hashing uses secure argon2id with appropriate memory/time cost settings
- Session strategy uses JWT with HttpOnly, Secure (in prod), SameSite=lax cookies
- User role is correctly set based on tier selection (basic/premium)
- Frontend displays field-level validation errors from backend
- Celebration modal redirects to /dashboard on success
- Form has proper accessibility attributes (aria-live, aria-busy, role="alert")
- Loading states shown during form submission
- Existing unit tests cover schema validation thoroughly

Verdict: PASS (code review confirms correct implementation)
================================================================================

================================================================================
Test: AUTH-002 - Signup validation rejects invalid inputs
Date: 2026-01-05T13:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/api/auth/signup/schema.ts - Zod validation schema
- apps/web/src/app/auth/signup/page.tsx - Frontend signup form component
- apps/web/src/app/api/auth/signup/route.ts - API endpoint with validation
- apps/web/src/app/api/auth/signup/route.test.ts - Unit tests for schema validation

Code Issues Found:
- ISSUE: No "confirm password" field in signup form - test step 7 cannot be verified
  The test expects password confirmation mismatch validation, but the signup form
  only has a single password field. This is a test/implementation mismatch.

Validation Analysis:
1. Invalid email format: ✅ IMPLEMENTED
   - Zod schema: z.string().email('Invalid email address')
   - Frontend displays error via validationErrors.email
   - Unit test confirms: 'not-an-email' is rejected

2. Password less than 8 characters: ✅ IMPLEMENTED
   - Zod schema: .min(8, 'Password must be at least 8 characters')
   - Also requires: uppercase letter and number
   - Unit test confirms: 'Pass1' (5 chars) is rejected

3. Password confirmation mismatch: ❌ NOT IMPLEMENTED
   - Signup form has NO confirmPassword field
   - Schema has no confirmPassword validation
   - This test step is not testable with current implementation

Frontend Error Display:
- Field-level errors shown via validationErrors state
- API returns 400 with { error: 'Validation failed', details: parsed.error.format() }
- Frontend parses details and displays per-field errors with role="alert"

Additional Password Validations (beyond test scope):
- Max 128 characters
- Requires at least one uppercase letter
- Requires at least one number

Unit Test Coverage:
- 12 test cases covering name, email, password, and tier validation
- All validation rules are tested

Observations:
- Backend validation is robust with comprehensive Zod schema
- Frontend properly displays server-side validation errors
- Password hint text shows requirements: "Must be at least 8 characters with one uppercase letter and one number"
- No client-side pre-validation before submit (relies on server validation)
- The missing confirm password field is likely a UX decision, not a bug

Verdict: FAIL (test step 7 "password confirmation mismatch" cannot be verified - no confirmPassword field exists)
================================================================================

================================================================================
Test: AUTH-003 - Sign in with valid credentials grants access
Date: 2026-01-05T14:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/auth/signin/page.tsx - Sign-in form with email/password and optional Discord OAuth
- apps/web/src/server/auth/config.ts - NextAuth configuration with credentials provider
- apps/web/src/server/auth/index.ts - NextAuth handlers and auth export
- apps/web/src/app/api/auth/[...nextauth]/route.ts - API route handler for NextAuth
- apps/web/src/app/dashboard/page.tsx - Protected dashboard page with redirect logic
- apps/web/src/app/dashboard/_components/DashboardClient.tsx - Dashboard UI with user info display
- apps/web/src/app/auth/_components/PasswordInput.tsx - Password input with show/hide toggle
- apps/web/prisma/seed.ts - Seed data with test users

Test Step Analysis:

1. Navigate to /auth/signin: ✅ IMPLEMENTED
   - Page renders correctly with email and password fields
   - Optional Discord OAuth button appears if NEXT_PUBLIC_DISCORD_CLIENT_ID is set
   - Link to /auth/signup for new users
   - Link to /auth/forgot-password for password reset

2. Enter valid email and password: ✅ IMPLEMENTED
   - Form inputs for email (type="email") and password
   - PasswordInput component includes accessible show/hide toggle
   - autoComplete attributes set correctly (email, current-password)

3. Submit the form: ✅ IMPLEMENTED
   - Uses next-auth/react signIn('credentials', { email, password, redirect: false })
   - Loading state shown during submission (aria-busy, spinner, disabled button)
   - Button text changes to "Signing you in..."

4. Verify redirect to dashboard: ✅ IMPLEMENTED
   - On success (result?.ok), calls router.push(callbackUrl) followed by router.refresh()
   - Default callbackUrl is '/dashboard' if not specified in searchParams
   - Supports custom callbackUrl via query parameter

5. Verify session cookie is set: ✅ IMPLEMENTED
   - Session strategy: 'jwt' (config.ts:151)
   - Cookie config (lines 155-168):
     * Production: __Secure-next-auth.session-token
     * Development: next-auth.session-token
     * HttpOnly: true
     * SameSite: 'lax'
     * Secure: true in production
     * Path: '/' (or BASE_PATH if set)

6. Verify user info is displayed correctly: ✅ IMPLEMENTED
   - Dashboard page (page.tsx) calls auth() to get session
   - Session includes: id, email, name, role (from JWT callbacks)
   - DashboardClient displays personalized greeting with user's first name
   - Role-based UI: premium users see premium features, admin sees admin link

Authentication Flow (authorize function, config.ts:102-137):
- Validates credentials with Zod schema (email: valid email, password: min 1 char)
- Queries database for user by email, includes password hash
- Verifies password with argon2id (same params as signup)
- Returns user object with id, email, name, image, role on success
- Returns null on failure (invalid credentials)

JWT Callbacks (config.ts:173-207):
- jwt callback: Attaches user id, email, role to token on sign-in
- session callback: Exposes id, email, role on session.user object
- Role fallback: Queries database if role not in token

Protected Route Pattern (dashboard/page.tsx):
- Server-side auth() check
- Redirects to /auth/signin?callbackUrl=/dashboard if no session

Error Handling:
- Invalid credentials: Shows "Invalid email or password" (generic message prevents enumeration)
- Network/unexpected errors: Shows connection error message, logs to console

Seed Data Users (seed.ts:142-186):
- NOTE: Test credentials in prompt say "free@example.com" but seed has "basic@example.com"
- premium@example.com / P@ssw0rd! (role: premium)
- basic@example.com / P@ssw0rd! (role: basic)
- admin@example.com / P@ssw0rd! (role: admin)

Accessibility Features:
- role="alert" on error messages with aria-live="polite"
- aria-busy on submit button during loading
- Proper label associations
- Keyboard-accessible show/hide password toggle with aria-label
- Loading spinner has aria-hidden="true"
- Suspense fallback shows loading state

Code Issues Found:
- DOCUMENTATION: Test credentials in prompt (free@example.com) don't match seed (basic@example.com)
  This is a documentation mismatch, not a code bug.

Observations:
- Implementation follows NextAuth.js v5 best practices
- Secure password handling with argon2id verification
- Proper cookie security attributes for session management
- Generic error message prevents username/email enumeration
- Clean separation between server and client components
- Role-based authorization properly propagated to session
- Loading and error states well-implemented with good UX
- Optional Discord OAuth support is gracefully conditional

Verdict: PASS (code review confirms all test steps are correctly implemented)
================================================================================

================================================================================
Test: AUTH-004 - Sign in rejects invalid credentials with helpful error
Date: 2026-01-05T15:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/auth/signin/page.tsx - Sign-in form with error handling
- apps/web/src/server/auth/config.ts - NextAuth credentials provider authorize function

Test Step Analysis:

1. Navigate to /auth/signin: ✅ IMPLEMENTED
   - Page renders with email/password form
   - Error display area uses role="alert" with aria-live="polite"

2. Enter incorrect password for valid email: ✅ HANDLED SECURELY
   - Backend authorize() returns null if password verification fails (config.ts:126-128)
   - Frontend catches result?.error and shows: "Invalid email or password" (signin/page.tsx:35)
   - Generic message does NOT reveal that the email exists

3. Verify generic error message (no credential enumeration): ✅ IMPLEMENTED
   - Same error message "Invalid email or password" shown for:
     * Invalid password with valid email
     * Non-existent email
     * Invalid email format (fails schema validation)
   - All failure paths return null from authorize(), triggering the same frontend error

4. Enter non-existent email: ✅ HANDLED SECURELY
   - Backend query returns null user (config.ts:110-113)
   - Condition `!user?.password?.hash` returns null (config.ts:115-117)
   - Frontend shows same generic error message

5. Verify same generic error message: ✅ CONFIRMED
   - No distinction between "user not found" and "wrong password"
   - This is correct security practice to prevent username enumeration

Backend Security Analysis (config.ts:102-137):
- Zod validation first (email format, password min 1 char)
- If validation fails: returns null (no specific error)
- If user not found: returns null (no specific error)
- If no password hash (OAuth-only user): returns null (no specific error)
- If password verification fails: returns null (no specific error)
- All failure modes are indistinguishable to the frontend

Frontend Error Display (signin/page.tsx:89-111):
- Error shown in amber-colored alert box with warning icon
- Uses role="alert" and aria-live="polite" for accessibility
- Error text: "Invalid email or password" (generic)
- Network errors show different message: "We couldn't sign you in right now..."

Code Issues Found:
- None - implementation follows security best practices

Observations:
- Credential enumeration attack is properly mitigated
- Error messages are user-friendly without leaking security information
- Consistent error handling across all failure scenarios
- Accessible error display with proper ARIA attributes
- Password verification uses argon2id with secure parameters

Verdict: PASS (code review confirms secure credential handling with no enumeration vulnerability)
================================================================================

================================================================================
Test: AUTH-005 - Password reset flow works end-to-end
Date: 2026-01-05T16:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/auth/forgot-password/page.tsx - Forgot password form requesting reset email
- apps/web/src/app/auth/reset-password/page.tsx - Reset password page with token validation
- apps/web/src/server/api/routers/passwordReset.ts - tRPC router with requestReset, verifyToken, resetPassword
- apps/web/src/server/email.ts - Email sending via nodemailer with HTML/text templates
- apps/web/prisma/schema.prisma - PasswordResetToken model with token, expiry, used fields

Test Step Analysis:

1. Navigate to /auth/forgot-password: ✅ IMPLEMENTED
   - Page renders with email input form
   - Back to sign in link provided
   - Uses AuthLayout component for consistent styling

2. Enter registered email address: ✅ IMPLEMENTED
   - Email input with type="email", autoComplete="email"
   - Controlled input with setEmail state

3. Submit the form: ✅ IMPLEMENTED
   - Calls api.passwordReset.requestReset.useMutation
   - Loading state: button shows "Sending..." while isPending
   - Error handling: displays error.message in red alert box

4. Verify success message is shown: ✅ IMPLEMENTED
   - On success, component re-renders to show success state (submitted=true)
   - Shows "Check your email" title with emerald success styling
   - Message: "If an account exists with [email], you'll receive..."
   - Informs user link expires in 1 hour, check spam folder

5. Check that reset token is created in database: ✅ IMPLEMENTED
   - passwordReset.ts:145-151 creates PasswordResetToken record
   - Token: 64-char hex string from randomBytes(32)
   - ExpiresAt: Date.now() + 1 hour (PASSWORD_RESET_TOKEN_EXPIRY)
   - Schema: id, token (unique), userId, expiresAt, used, usedAt

6. Navigate to reset link with token: ✅ IMPLEMENTED
   - reset-password/page.tsx reads token from searchParams
   - Calls api.passwordReset.verifyToken.useQuery to validate token
   - Shows loading state: "Verifying reset link..."
   - Invalid/expired token shows: "Invalid reset link" with explanation

7. Enter new password: ✅ IMPLEMENTED
   - PasswordInput components for password and confirmPassword
   - Client-side validation: min 8 chars, passwords must match
   - Shows password requirements hint
   - Accessible: aria-describedby for requirements

8. Verify password is updated: ✅ IMPLEMENTED
   - resetPassword mutation (line 265-362):
     - Validates token exists, not used, not expired
     - Hashes new password with argon2id (same params as signup)
     - Uses transaction to update Password and mark token used
   - On success: shows "Password reset successful" with checkmark
   - Auto-redirects to /auth/signin after 3 seconds

9. Sign in with new password succeeds: ✅ IMPLEMENTED
   - Standard sign-in flow uses the new password hash
   - Password model updated via upsert (handles OAuth-only users upgrading)

Security Features:
- Rate limiting: MAX_RESET_REQUESTS_PER_HOUR = 3 per email
- No user enumeration: Always returns same message regardless of email existence
- Token expiry: 1 hour (PASSWORD_RESET_TOKEN_EXPIRY)
- Token single-use: marked used=true with usedAt timestamp after use
- Secure token generation: crypto.randomBytes(32)
- Password hashing: argon2id with memoryCost=19456, timeCost=2
- Comprehensive logging with anonymized data (email hash, token hash)

Email Template (email.ts:93-178):
- HTML email with responsive design
- Plain text fallback included
- Reset URL uses NEXTAUTH_URL environment variable
- Branded "MealMind AI" styling with emerald button
- Warning box about 1-hour expiry
- "If you didn't request this" disclaimer

Code Issues Found:
- MINOR: Reset password page only validates min 8 chars client-side (line 47)
  but signup requires uppercase + number. This means reset passwords have
  weaker requirements than signup passwords. However, the backend schema
  only requires min 8 (z.string().min(8)), so this is consistent with backend.
  Consider adding same validation as signup for consistency.

Observations:
- Full password reset flow is implemented and functional
- All security best practices followed (rate limiting, no enumeration, token expiry)
- Good UX with loading states, success messages, and auto-redirect
- Email template is professional and mobile-friendly
- Token verification happens before showing password form
- Transaction ensures atomic update of password + token used state
- Logging provides audit trail without exposing sensitive data

Verdict: PASS (code review confirms complete, secure password reset implementation)
================================================================================

================================================================================
Test: AUTH-006 - Protected routes redirect unauthenticated users
Date: 2026-01-05T17:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/dashboard/page.tsx - Server component with auth() check and redirect
- apps/web/src/app/planner/page.tsx - Client component using useSession (NO server protection)
- apps/web/src/app/plan/[id]/page.tsx - Server component with auth() check and redirect
- apps/web/src/app/planner/last/page.tsx - Server component with auth() check and redirect
- apps/web/src/server/auth/index.ts - NextAuth exports with cached auth()
- apps/web/src/server/api/routers/plan.ts - tRPC routes using protectedProcedure
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Client component (no auth check)

Test Step Analysis:

1. Navigate to /dashboard without auth: ✅ PROTECTED
   - Server component checks `const session = await auth()`
   - Redirects: `if (!session?.user) { redirect('/auth/signin?callbackUrl=/dashboard'); }`
   - Location: dashboard/page.tsx:10-12

2. Navigate to /planner without auth: ⚠️ PARTIALLY PROTECTED (API-level only)
   - Page is a client component ('use client')
   - Uses useSession() but does NOT redirect unauthenticated users
   - Page RENDERS for unauthenticated users showing the MealPlanWizard
   - When user tries to generate plan, api.plan.generate (protectedProcedure) fails
   - Error: tRPC returns UNAUTHORIZED but user sees confusing error state
   - ISSUE: Should have server-side redirect like /dashboard

3. Navigate to /plan/[id] without auth: ✅ PROTECTED
   - Server component checks `const session = await auth()`
   - Redirects: `if (!session?.user) { redirect('/auth/signin'); }`
   - Location: plan/[id]/page.tsx:17-19

4. Navigate to /planner/last without auth: ✅ PROTECTED
   - Server component checks `const session = await auth()`
   - Redirects: `if (!session?.user) { redirect('/auth/signin'); }`
   - Location: planner/last/page.tsx:8-10

Backend Protection (tRPC):
- plan.generate: protectedProcedure ✅ (line 20)
- plan.getById: protectedProcedure ✅ (line 112)
- plan.getLast: protectedProcedure ✅ (line 157)
- All plan routes require authentication at API level

Code Issues Found:
- BUG: /planner page lacks server-side authentication redirect
  - The page is a client component that renders for unauthenticated users
  - Users can see the MealPlanWizard and fill out the form
  - When they submit, the API call fails with UNAUTHORIZED
  - This creates a poor UX: user invests time filling form, then gets error
  - RECOMMENDATION: Convert to server component with auth check, or add
    wrapper layout that checks auth, or add client-side redirect in useEffect

Missing Middleware:
- No custom middleware.ts file exists in the project
- Route protection is handled per-page rather than via middleware
- This is acceptable but requires each protected page to include auth check

Observations:
- 3 out of 4 protected routes correctly redirect unauthenticated users
- /planner is the exception - renders UI but fails on API call
- Backend tRPC routes are properly protected with protectedProcedure
- The callbackUrl pattern is correctly implemented for post-login redirect
- Pattern inconsistency: /dashboard uses `?callbackUrl=/dashboard`, /plan/[id] omits it

Verdict: FAIL (BUG: /planner page renders for unauthenticated users without redirect)
================================================================================

================================================================================
Test: AUTH-007 - Sign out clears session and redirects appropriately
Date: 2026-01-05T18:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/layout/Header.tsx - Sign out button with handleSignOut function
- apps/web/src/server/auth/index.ts - NextAuth exports including signOut
- apps/web/src/server/auth/config.ts - Session and cookie configuration
- apps/web/src/app/api/auth/[...nextauth]/route.ts - NextAuth API handlers
- apps/web/src/app/_components/Header.test.tsx - Unit tests for Header component

Test Step Analysis:

1. Sign in with valid credentials: ✅ PREREQUISITE (covered in AUTH-003)
   - User authenticates via NextAuth credentials provider
   - JWT session cookie is set with HttpOnly, Secure (prod), SameSite=lax

2. Click sign out button: ✅ IMPLEMENTED
   - Desktop: Button in header navigation (Header.tsx:75-77)
   - Mobile: Button in Sheet side panel (Header.tsx:126-134)
   - Both call handleSignOut() function

3. Verify session cookie is cleared: ✅ IMPLEMENTED BY NEXTAUTH
   - handleSignOut() calls signOut() from next-auth/react (line 3, 52)
   - signOut({ callbackUrl: `${basePath}/` }) triggers NextAuth sign out flow
   - NextAuth /api/auth/signout endpoint clears the session token cookie
   - Cookie name: __Secure-next-auth.session-token (prod) or next-auth.session-token (dev)
   - NextAuth sets cookie expiry to past date, effectively deleting it

4. Verify redirect to home or signin page: ✅ IMPLEMENTED
   - callbackUrl is set to `${basePath}/` (home page) in handleSignOut()
   - After sign out, user is redirected to the root URL
   - basePath defaults to empty string if NEXT_PUBLIC_BASE_PATH not set

5. Attempt to access /dashboard: ✅ PROTECTED (covered in AUTH-006)
   - After sign out, session is null
   - /dashboard server component calls auth()
   - Redirects to /auth/signin?callbackUrl=/dashboard

6. Verify redirect to signin: ✅ IMPLEMENTED
   - Protected route pattern correctly redirects unauthenticated users
   - callbackUrl preserved for post-login redirect

Sign Out Flow Analysis:
1. User clicks "Sign out" button in Header
2. handleSignOut() is called (async function)
3. signOut({ callbackUrl: `${basePath}/` }) is invoked
4. NextAuth client library:
   - Makes POST request to /api/auth/signout
   - Server clears session cookie
   - Returns redirect URL
5. Browser redirects to home page (/)
6. useSession() now returns null/unauthenticated
7. Header conditionally renders (no nav items for logged-out user)

Desktop vs Mobile Implementation:
- Desktop: Direct onClick={handleSignOut} (line 75)
- Mobile: Wrapped in closure that first closes menu, then signs out:
  onClick={() => { setMobileMenuOpen(false); void handleSignOut(); }}
  This ensures mobile menu closes before redirect

Unit Test Coverage (Header.test.tsx):
- Tests mock signOut function (line 9)
- Tests verify hamburger button hidden when unauthenticated (line 35-45)
- No explicit test for sign out flow execution (relies on NextAuth integration)

Code Issues Found:
- None - implementation follows NextAuth best practices

Observations:
- Sign out implementation is straightforward using NextAuth's signOut()
- Redirect to home (/) rather than /auth/signin is a good UX choice
- Mobile menu properly closes before sign out to avoid UI flash
- Header correctly hides navigation/sign out when session is null
- Cookie security attributes (HttpOnly, Secure, SameSite) are preserved
- No sign-out confirmation dialog - immediate sign out on click
- basePath support allows deployment at non-root URLs

Verdict: PASS (code review confirms correct sign out implementation with session clearing and redirect)
================================================================================

================================================================================
Test: PLAN-001 - Basic meal plan generation creates valid 7-day plan
Date: 2026-01-05T19:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/planner/page.tsx - Client component with MealPlanWizard and generation states
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Form for plan preferences
- apps/web/src/server/api/routers/plan.ts - tRPC router with generate, getById, getLast, swapRecipe
- apps/web/src/server/services/planGenerator.ts - Core plan generation logic
- apps/web/src/server/repositories/recipes.ts - Recipe filtering and query logic
- apps/web/src/app/plan/[id]/page.tsx - Plan view page with meal display
- apps/web/prisma/schema.prisma - MealPlan and MealPlanItem models

Test Step Analysis:

1. Sign in as authenticated user: ✅ PROTECTED
   - plan.generate uses protectedProcedure (plan.ts:20)
   - Plan view page (plan/[id]/page.tsx:17-19) redirects unauthenticated users
   - NOTE: /planner page itself doesn't redirect (known issue from AUTH-006)

2. Navigate to /planner: ✅ IMPLEMENTED
   - Page renders MealPlanWizard component
   - Wizard is modal-style with full-screen on mobile, centered dialog on desktop

3. Select 7 days, 3 meals per day, household size 2: ✅ IMPLEMENTED
   - MealPlanWizard has form controls:
     * householdSize: dropdown (1-6 people) - line 349-368
     * mealsPerDay: dropdown (1, 2, or 3 meals) - line 386-404
     * days: dropdown (3-7 days) - line 422-450
   - Premium restriction enforced: non-premium limited to 3 days (line 432-438)
   - Backend also validates: maxDays = user.role === 'premium' ? 7 : 3 (planGenerator.ts:85)

4. Leave dietary restrictions unchecked: ✅ IMPLEMENTED
   - isVegetarian and isDairyFree default to false (line 56-57)
   - Optional dislikes text input (line 506-530)
   - Advanced filters collapsible: difficulty, maxTime, allergens (line 533-683)

5. Generate the meal plan: ✅ IMPLEMENTED
   - handleSubmit (line 108-121) calls onComplete with MealPreferences
   - planner/page.tsx handleWizardComplete (line 56-71) triggers generatePlan.mutate
   - API call: plan.generate mutation (plan.ts:20-109)
   - Loading state with rotating messages (lines 89-115)
   - Success animation before redirect (lines 117-143)

6. Verify plan contains 21 meals (7 days x 3 meals): ✅ VALIDATED BY CODE
   - PlanGenerator.generatePlan (planGenerator.ts:58-217):
     * Iterates days x mealTypes (lines 136-183)
     * Creates mealPlanItemsData array with dayIndex, mealType, recipeId, servings
     * Transaction creates MealPlan + MealPlanItems (lines 186-211)
   - validateGeneratedPlan (lines 222-352):
     * Verifies exact item count: expectedDays * mealTypes.length (lines 236-252)
     * Verifies each day has all expected meal types (lines 254-297)
     * Verifies recipe mealType assignment is correct (lines 299-342)
   - Throws PLAN_VALIDATION_FAILED if counts don't match

7. Verify each day has breakfast, lunch, and dinner: ✅ VALIDATED BY CODE
   - getMealTypesForCount(3) returns ['breakfast', 'lunch', 'dinner'] (lines 385-397)
   - validateGeneratedPlan checks each dayIndex has all expected meal types
   - Schema: MealPlanItem has dayIndex (0-based) and mealType string

8. Verify redirect to plan view page: ✅ IMPLEMENTED
   - On mutation success: router.push(`/plan/${data.id}`) (line 31-32)
   - Success animation shows for 2.5s before redirect (line 30)
   - Plan view page loads with full plan data from getById query

Data Model (schema.prisma:285-312):
- MealPlan: id, userId, startDate, days, items[], shoppingList?, timestamps
- MealPlanItem: id, planId, dayIndex, mealType, recipeId, servings, timestamps
- Proper cascade delete relationships

Recipe Filtering (recipes.ts:89-100, 346-408):
- findForPlanning() builds where clause with all filters
- Supports: status, isVegetarian, isDairyFree, difficulty, mealTypes
- Supports: dietTagIds, excludeAllergenTagIds, maxPrepTime, maxCookTime, maxTotalTime
- filterRecipesByDislikes() excludes recipes with disliked ingredients

Error Handling:
- NO_RECIPES_AVAILABLE: No recipes in database
- NO_RECIPES_MATCH_PREFERENCES: All recipes filtered out by preferences
- NO_RECIPES_FOR_MEAL_TYPE: No recipes for specific meal (breakfast/lunch/dinner)
- PLAN_VALIDATION_FAILED: Post-generation validation failed
- Role-based day limit exceeded: Shows upgrade prompt for non-premium

Shopping List Generation:
- Automatically created after plan generation (plan.ts:62-69)
- Failure logged but doesn't block plan creation

Unit Tests (plan.test.ts):
- Tests plan generation with mock PlanGenerator
- Tests error mapping (NO_RECIPES_FOR_MEAL_TYPE → BAD_REQUEST)
- Tests PLAN_LIMIT_EXCEEDED → FORBIDDEN
- Tests swapRecipe authorization and functionality

Code Issues Found:
- None for core meal plan generation logic - implementation is robust

Observations:
- Plan generation is well-architected with separation of concerns
- Repository pattern provides clean data access abstraction
- PlanGenerator has comprehensive validation after generation
- Fisher-Yates shuffle provides recipe variety (planGenerator.ts:370-376)
- Meal type selection is intelligent: 1 meal=dinner, 2=lunch+dinner, 3=all
- Shopping list auto-generation is resilient (logs errors, doesn't fail)
- Premium vs basic tier restrictions enforced at both frontend and backend
- Visual feedback excellent: loading messages, progress bar, success animation

Verdict: PASS (code review confirms complete, validated 7-day meal plan generation)
================================================================================

================================================================================
Test: PLAN-002 - Vegetarian filter excludes meat-based recipes
Date: 2026-01-05T20:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Form with isVegetarian checkbox (lines 56, 469-483)
- apps/web/src/app/planner/page.tsx - Passes isVegetarian to API mutation (lines 56-71)
- apps/web/src/server/api/routers/plan.ts - API endpoint accepts isVegetarian (lines 27, 46)
- apps/web/src/server/services/planGenerator.ts - Passes filter to repository (lines 65, 100-103)
- apps/web/src/server/repositories/recipes.ts - Builds WHERE clause for isVegetarian (lines 353-355)
- apps/web/prisma/schema.prisma - Recipe model has isVegetarian Boolean field (line 173)
- apps/web/prisma/seed.ts - Seed data with isVegetarian flags on recipes

Test Step Analysis:

1. Sign in as authenticated user: ✅ IMPLEMENTED
   - plan.generate uses protectedProcedure (plan.ts:20)

2. Navigate to /planner: ✅ IMPLEMENTED
   - MealPlanWizard renders with dietary preferences section

3. Enable vegetarian dietary restriction: ✅ IMPLEMENTED
   - Checkbox at MealPlanWizard.tsx:469-483
   - State managed via useState: const [isVegetarian, setIsVegetarian] = useState(false)
   - Included in form submission: onComplete({ ..., isVegetarian, ... }) at line 114

4. Generate a 3-day meal plan: ✅ IMPLEMENTED
   - handleWizardComplete passes isVegetarian to generatePlan.mutate (planner/page.tsx:63)

5. Verify all recipes in plan are vegetarian-tagged: ✅ VALIDATED BY CODE
   - Flow:
     a. Frontend passes isVegetarian: true to API
     b. plan.ts:46 passes to generator: isVegetarian: input.isVegetarian
     c. planGenerator.ts:100-103 passes to repository:
        isVegetarian: isVegetarian || undefined
        (only filters when true, undefined means no filter)
     d. recipes.ts:353-355 builds where clause:
        if (filters.isVegetarian !== undefined) {
          where.isVegetarian = filters.isVegetarian;
        }
   - Prisma query: WHERE isVegetarian = true

6. Verify no meat-containing recipes appear: ✅ VALIDATED BY CODE
   - Database-level filtering ensures only recipes with isVegetarian=true are returned
   - Seed data analysis shows 17 vegetarian recipes available:
     * Breakfast: Classic Irish Porridge, Scrambled Eggs on Toast, Buttermilk Pancakes,
       Avocado Toast, Greek Yogurt Parfait, French Toast, Breakfast Smoothie Bowl
     * Lunch/Dinner: Mediterranean Pasta Salad, Vegetable Lasagne, Vegetarian Stir-Fry Bowl,
       Chickpea Curry, Pasta with Tomato Sauce, Egg Fried Rice, Mushroom Risotto,
       Roasted Vegetable Bowl, Lentil & Vegetable Soup, Veggie Chilli with Rice
   - Non-vegetarian recipes (chicken, beef, pork, salmon, tuna, bacon, sausage) are excluded

Recipe Filter Implementation Deep Dive:
- RecipeRepository.findForPlanning() builds Prisma where clause
- When isVegetarian=true is passed, it adds: { isVegetarian: true }
- This is an exact equality check, not hasSome or contains
- Only recipes with the boolean field set to true will be returned
- The recipe schema uses a simple Boolean field (not a tag-based system for vegetarian)

Seed Data Verification:
- 17 recipes have isVegetarian: true
- 13 recipes have isVegetarian: false (meat-based)
- Meat recipes include: Chicken Stir Fry, Beef Shepherd's Pie, Thai Red Curry,
  Salmon, Bacon Fried Rice, Sausage Stew, Irish Beef Stew, Tuna Pasta Bake,
  Chicken Fajitas, Pork Chops, Creamy Chicken Pasta, Chicken Noodle Stir-Fry,
  Full Irish Breakfast

Additional Validation:
- The planGenerator.validateGeneratedPlan() runs after generation
- It verifies each recipe's mealTypes match the assigned slot
- However, it does NOT re-validate dietary flags (assumes DB filtering is correct)

Code Issues Found:
- None - vegetarian filter is correctly implemented at database level

Observations:
- Simple boolean field approach is straightforward and efficient
- Database-level filtering is secure (no client-side manipulation possible)
- Seed data properly tags recipes as vegetarian/non-vegetarian
- Some edge cases to consider: eggs are included in "vegetarian" (ovo-vegetarian)
  which is correct per common definition
- The filter works correctly when enabled; disabling returns all recipes
- Premium users and basic users both have access to vegetarian filter

Verdict: PASS (code review confirms vegetarian filter correctly excludes meat-based recipes via database query)
================================================================================

================================================================================
Test: PLAN-003 - Dairy-free filter excludes dairy-containing recipes
Date: 2026-01-05T21:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Form with isDairyFree checkbox (lines 57, 484-502)
- apps/web/src/app/planner/page.tsx - Passes isDairyFree to API mutation
- apps/web/src/server/api/routers/plan.ts - API endpoint accepts isDairyFree
- apps/web/src/server/services/planGenerator.ts - Passes filter to repository (lines 66, 103)
- apps/web/src/server/repositories/recipes.ts - Builds WHERE clause for isDairyFree (lines 357-359)
- apps/web/prisma/seed.ts - Seed data with isDairyFree flags on recipes
- apps/web/src/lib/ingredients/derivation.ts - Derivation logic for isDairyFree from canonical ingredients

Test Step Analysis:

1. Sign in as authenticated user: ✅ IMPLEMENTED
   - plan.generate uses protectedProcedure (plan.ts:20)

2. Navigate to /planner: ✅ IMPLEMENTED
   - MealPlanWizard renders with dietary preferences section

3. Enable dairy-free dietary restriction: ✅ IMPLEMENTED
   - Checkbox at MealPlanWizard.tsx:484-502
   - State managed via useState: const [isDairyFree, setIsDairyFree] = useState(false)
   - Included in form submission: onComplete({ ..., isDairyFree, ... }) at line 115

4. Generate a 3-day meal plan: ✅ IMPLEMENTED
   - handleWizardComplete passes isDairyFree to generatePlan.mutate

5. Verify all recipes in plan are dairy-free: ✅ VALIDATED BY CODE
   - Flow:
     a. Frontend passes isDairyFree: true to API
     b. plan.ts passes to generator: isDairyFree: input.isDairyFree
     c. planGenerator.ts:103 passes to repository:
        isDairyFree: isDairyFree || undefined
        (only filters when true, undefined means no filter)
     d. recipes.ts:357-359 builds where clause:
        if (filters.isDairyFree !== undefined) {
          where.isDairyFree = filters.isDairyFree;
        }
   - Prisma query: WHERE isDairyFree = true

6. Check recipe ingredients for dairy products: ✅ VALIDATED BY CODE
   - Seed data analysis shows 16 dairy-free recipes available:
     * Chicken & Vegetable Stir Fry (isDairyFree: true)
     * Thai Red Curry with Rice (isDairyFree: true)
     * Salmon with Roasted Vegetables (isDairyFree: true)
     * Vegetarian Stir-Fry Bowl (isDairyFree: true)
     * Chickpea Curry (isDairyFree: true)
     * Egg Fried Rice (isDairyFree: true)
     * Roasted Vegetable Bowl (isDairyFree: true)
     * Quick Bacon & Egg Fried Rice (isDairyFree: true)
     * One-Pot Sausage & Bean Stew (isDairyFree: true)
     * Irish Beef & Guinness Stew (isDairyFree: true)
     * Lentil & Vegetable Soup (isDairyFree: true)
     * Quick Pork Chops with Roast Veg (isDairyFree: true)
     * Veggie Chilli with Rice (isDairyFree: true)
     * Chicken Noodle Stir-Fry (isDairyFree: true)
     * Avocado Toast with Poached Egg (isDairyFree: true)
     * Breakfast Smoothie Bowl (isDairyFree: true)
   - Non-dairy-free recipes (14 total) include: milk, cheese, butter, cream, yogurt, buttermilk

Derivation Logic Analysis (derivation.ts):
- deriveRecipeTags() computes isDairyFree by checking ALL ingredients
- Recipe is only dairy-free if ALL ingredients are dairy-free
- Each ingredient's isDairyFree flag comes from canonical ingredient data
- Seed script uses deriveRecipeTags() to update recipe isDairyFree field (lines 1680-1689)
- This ensures database-level filtering matches actual ingredient composition

Dairy Ingredient Categories in Seed Data:
- milk (dairy) → containsDairy: true → makes recipe NOT dairy-free
- cheese (dairy) → containsDairy: true → makes recipe NOT dairy-free
- butter (dairy) → containsDairy: true → makes recipe NOT dairy-free
- yogurt (dairy) → containsDairy: true → makes recipe NOT dairy-free
- cream (dairy) → containsDairy: true → makes recipe NOT dairy-free
- cheddar cheese (dairy) → containsDairy: true → makes recipe NOT dairy-free
- buttermilk (dairy) → containsDairy: true → makes recipe NOT dairy-free
- greek yogurt (dairy) → containsDairy: true → makes recipe NOT dairy-free
- almond milk (dairy) → isDairyFree: true → DOES NOT break dairy-free status

Edge Cases Covered:
- Almond milk is correctly marked as dairy-free (non-dairy alternative)
- Coconut milk is correctly marked as dairy-free (non-dairy alternative)
- Recipes using butter, milk, cream, cheese are correctly excluded

Meal Type Coverage for Dairy-Free:
- Breakfast: Avocado Toast with Poached Egg, Breakfast Smoothie Bowl
- Lunch/Dinner: Multiple options available
- All meal types have at least 1 dairy-free option

Code Issues Found:
- None - dairy-free filter is correctly implemented at database level

Observations:
- Simple boolean field approach is consistent with vegetarian filter
- Database-level filtering is secure (no client-side manipulation possible)
- Seed data correctly derives isDairyFree from ingredient composition
- Derivation logic uses canonical ingredient data for accuracy
- Both primary diary-free checkbox AND advanced allergen exclusion for dairy exist
  (users can use either approach)
- Premium users and basic users both have access to dairy-free filter

Verdict: PASS (code review confirms dairy-free filter correctly excludes dairy-containing recipes via database query)
================================================================================

================================================================================
Test: PLAN-004 - Disliked ingredients are excluded from plan
Date: 2026-01-05T22:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Dislikes text input (lines 58, 506-530)
- apps/web/src/app/planner/page.tsx - Passes dislikes to API mutation
- apps/web/src/server/api/routers/plan.ts - API endpoint accepts dislikes (line 29, 48)
- apps/web/src/server/services/planGenerator.ts - Calls parseDislikes and filterRecipesByDislikes (lines 97, 119)
- apps/web/src/server/repositories/recipes.ts - filterRecipesByDislikes() and parseDislikes() functions (lines 541-569)
- apps/web/src/server/repositories/recipes.test.ts - Unit tests for dislikes filtering (lines 410-519)

Test Step Analysis:

1. Sign in and set up user preferences with disliked ingredients: ⚠️ PARTIAL
   - NOTE: The dislikes field is entered per-plan via MealPlanWizard, NOT saved to user preferences
   - MealPlanWizard.tsx:506-530: Text input with placeholder "e.g., mushrooms, olives, cilantro"
   - Dislikes are passed directly in the generate mutation, not loaded from user profile
   - User preferences model DOES have a dislikes field, but it's only used in swapRecipe

2. Navigate to /planner: ✅ IMPLEMENTED
   - MealPlanWizard renders with dislikes text input

3. Generate a meal plan: ✅ IMPLEMENTED
   - handleWizardComplete passes dislikes string to generatePlan.mutate
   - Flow:
     a. MealPlanWizard captures dislikes string (line 116)
     b. planner/page.tsx passes to API: dislikes: prefs.dislikes
     c. plan.ts:48 passes to generator: dislikes: input.dislikes
     d. planGenerator.ts:97 calls parseDislikes(dislikes)
     e. planGenerator.ts:119 calls filterRecipesByDislikes(recipesMatchingDiet, dislikeTerms)

4. Verify no recipes contain disliked ingredients: ✅ VALIDATED BY CODE

parseDislikes Function (recipes.ts:563-569):
- Splits on commas
- Trims whitespace
- Converts to lowercase
- Filters empty entries
- Returns string[] of dislike terms

filterRecipesByDislikes Function (recipes.ts:541-558):
- If dislikeTerms is empty, returns all recipes (short-circuit)
- For each recipe, extracts all ingredient names (lowercase)
- Uses partial matching: checks if any ingredient name.includes(dislikeTerm)
- Filters OUT recipes where ANY ingredient contains a dislike term
- Returns only recipes with NO disliked ingredients

Example: dislikes="mushrooms, olives"
- Parsed to: ['mushrooms', 'olives']
- Recipe with "baby mushrooms" ingredient → EXCLUDED (mushrooms matches)
- Recipe with "kalamata olives" ingredient → EXCLUDED (olives matches)
- Recipe with "olive oil" ingredient → EXCLUDED (olives matches 'olive')
  ⚠️ EDGE CASE: "olives" will also exclude "olive oil" due to partial match

5. Check multiple recipes to confirm exclusion: ✅ VALIDATED BY CODE & TESTS

Unit Test Coverage (recipes.test.ts:410-485):
- 7 test cases for filterRecipesByDislikes
- Tests: empty dislikes, single dislike, case-insensitive, partial matches, multiple dislikes
- Tests: keeps recipes with empty ingredients
- All tests pass

Potential Edge Cases/Issues:
1. EDGE CASE: Partial matching may be too aggressive
   - "peas" will exclude both "snap peas" and "chickpeas"
   - "olives" will exclude "olive oil"
   - "cream" will exclude "ice cream" and "cream cheese"
   NOTE: swapRecipe (plan.ts:311-318) has smarter word-boundary matching that avoids this

2. DESIGN: Dislikes are per-plan, not saved to user profile
   - User must re-enter dislikes for each new plan
   - swapRecipe uses user.preferences.dislikes (saved profile)
   - INCONSISTENCY: New plan uses form input, swap uses saved preferences

3. MINOR: No autocomplete for common dislikes
   - Users must type ingredients manually
   - Could mistype or use non-standard names

swapRecipe Comparison (plan.ts:304-321):
- Uses smarter matching: checks exact match OR whole word in multi-word ingredient
- e.g., "peas" matches "snap peas" but NOT "chickpeas"
- This is better logic than filterRecipesByDislikes uses

Code Issues Found:
- INCONSISTENCY: filterRecipesByDislikes uses simple partial matching, but swapRecipe
  uses smarter word-boundary matching. These should be consistent.
- DESIGN: Per-plan dislikes not saved to user preferences for reuse
- EDGE CASE: Partial matching can over-exclude (olive→olive oil, peas→chickpeas)

Observations:
- Core functionality is correctly implemented - disliked ingredients ARE excluded
- Comprehensive unit test coverage for the filtering logic
- Two different matching strategies exist (partial vs word-boundary) - should be unified
- User experience could be improved by saving dislikes to profile
- Placeholder text provides good examples for users
- The filtering happens AFTER dietary filters (vegetarian/dairy-free) are applied
- If all recipes are filtered out, proper error message shown: "No recipes match your preferences"

Verdict: PASS (code review confirms disliked ingredients are excluded from plan; edge case with partial matching noted but core functionality works correctly)
================================================================================

================================================================================
Test: PLAN-005 - Advanced filters work correctly (difficulty, cook time)
Date: 2026-01-05T23:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Advanced filters UI (lines 61-65, 533-683)
- apps/web/src/server/api/routers/plan.ts - API accepts difficulty/maxTotalTime (lines 31-32, 50-51)
- apps/web/src/server/services/planGenerator.ts - Passes filters to repository (lines 69-72, 105-106)
- apps/web/src/server/repositories/recipes.ts - buildWhereClause with difficulty/time filters (lines 361-405)
- apps/web/prisma/seed.ts - Difficulty assignment logic (line 1618)
- apps/web/src/server/repositories/recipes.test.ts - Unit tests for repository

Test Step Analysis:

1. Navigate to /planner: ✅ IMPLEMENTED
   - MealPlanWizard renders with "Advanced Options" collapsible section (line 533-683)
   - Click expands to show difficulty, max time, and allergen filters

2. Set difficulty filter to EASY only: ✅ IMPLEMENTED
   - Dropdown with options: "Any difficulty", "Easy", "Medium", "Hard" (lines 584-600)
   - State: useState<'EASY' | 'MEDIUM' | 'HARD' | null>(null) (line 63)
   - Passed to API: difficulty: input.difficulty ?? undefined (plan.ts:50)

3. Set max cook time to 30 minutes: ✅ IMPLEMENTED
   - Dropdown with options: "Any time", "15 min or less", "30 min or less", etc. (lines 38-46, 608-643)
   - State: useState<number | null>(null) (line 64)
   - Passed to API: maxTotalTime: input.maxTotalTime ?? undefined (plan.ts:51)

4. Generate meal plan: ✅ IMPLEMENTED
   - handleSubmit includes difficulty and maxTotalTime in preferences (lines 117-118)
   - Flow: MealPlanWizard → planner/page.tsx → plan.generate mutation

5. Verify all recipes are EASY difficulty: ✅ VALIDATED BY CODE
   - planGenerator.ts:105 passes difficulty to repository
   - recipes.ts:361-363 builds WHERE clause:
     ```
     if (filters.difficulty) {
       where.difficulty = filters.difficulty;
     }
     ```
   - Prisma query: WHERE difficulty = 'EASY'

6. Verify all recipes have total time <= 30 minutes: ✅ VALIDATED BY CODE
   - planGenerator.ts:106 passes maxTotalTime to repository
   - recipes.ts:403-405 builds WHERE clause:
     ```
     if (filters.maxTotalTime !== undefined) {
       where.totalTimeMinutes = { lte: filters.maxTotalTime };
     }
     ```
   - Prisma query: WHERE totalTimeMinutes <= 30

Seed Data Analysis (Difficulty Distribution):
- Difficulty is derived from recipe minutes in seed.ts:1617-1618:
  * EASY: minutes <= 15 (Quick recipes)
  * MEDIUM: minutes > 15 AND minutes <= 35
  * HARD: minutes > 35
- totalTimeMinutes is set directly from recipeInfo.minutes (line 1621)

Recipe Examples by Difficulty (from seed data analysis):
- EASY (≤15 min): Quick scrambled eggs, toast, smoothie bowl
- MEDIUM (16-35 min): Pasta dishes, stir-fries, simple curries
- HARD (>35 min): Stews, lasagne, slow-cooked dishes

Combined Filter Behavior:
- When both difficulty=EASY and maxTotalTime=30 are set:
  * EASY recipes are ≤15 minutes (all pass 30-minute filter)
  * Filter is redundant but correctly applied
- Both filters can be combined with dietary filters (vegetarian, dairy-free, allergens)

Repository Implementation Analysis (buildWhereClause):
- filters.difficulty → exact match on Recipe.difficulty enum
- filters.maxTotalTime → totalTimeMinutes <= value (lte operator)
- filters.maxPrepTime → prepTimeMinutes <= value
- filters.maxCookTime → cookTimeMinutes <= value
- All filters are ANDed together in the WHERE clause

Additional Time Filters Available (not exposed in UI):
- maxPrepTime: filters by prepTimeMinutes (repository supports, UI does not expose)
- maxCookTime: filters by cookTimeMinutes (repository supports, UI does not expose)
- NOTE: UI exposes maxTotalTime which is prepTime + cookTime combined

Unit Test Coverage:
- recipes.test.ts has tests for dietary filters (lines 306-337)
- No dedicated tests for difficulty/maxTotalTime filters in repository tests
- The buildWhereClause is tested implicitly through findForPlanning tests
- RECOMMENDATION: Add explicit tests for advanced filters

Error Handling:
- If difficulty/time filters exclude all recipes:
  * NO_RECIPES_MATCH_PREFERENCES error thrown (planGenerator.ts:122-125)
  * Frontend shows: "No recipes match your preferences. Please adjust and try again."

Code Issues Found:
- MINOR: No unit tests specifically for difficulty and maxTotalTime filters
  The repository has the code path but no dedicated test coverage.
- MINOR: UI labels "Maximum cooking time" but filters on totalTimeMinutes (prep + cook)
  This is slightly misleading - should be "Maximum total time" for accuracy.

Observations:
- Advanced filters are fully implemented end-to-end
- Difficulty filter uses exact enum match (EASY/MEDIUM/HARD)
- Time filter uses totalTimeMinutes (prepTime + cookTime combined)
- Filters are correctly passed through all layers: UI → API → Generator → Repository → Prisma
- Seed data derives difficulty from time, creating sensible defaults
- All advanced filters can be combined with dietary preferences
- UI shows active filter count badge (line 544-557)
- Repository supports additional time filters (prep, cook) not exposed in UI

Verdict: PASS (code review confirms difficulty and time filters are correctly implemented at all layers)
================================================================================

================================================================================
Test: PLAN-006 - Allergen exclusion filters work correctly
Date: 2026-01-05T23:30:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - UI with allergen selection (lines 26-36, 645-680)
- apps/web/src/app/planner/page.tsx - Passes excludeAllergenTagIds to API (line 69)
- apps/web/src/server/api/routers/plan.ts - API accepts excludeAllergenTagIds (line 34, 53)
- apps/web/src/server/services/planGenerator.ts - Passes excludeAllergenTagIds to repository (line 72, 108)
- apps/web/src/server/repositories/recipes.ts - buildWhereClause for allergen exclusion (lines 377-383)
- apps/web/prisma/schema.prisma - AllergenTag model with id (CUID) and name fields (lines 436-446)
- apps/web/prisma/seed.ts - Creates allergen tags with auto-generated CUIDs (lines 420-426)

Test Step Analysis:

1. Navigate to /planner: ✅ IMPLEMENTED
   - MealPlanWizard has "Advanced Options" section with allergen exclusions
   - 9 allergen options available: gluten, dairy, eggs, nuts, peanuts, soy, shellfish, fish, sesame
   - Each allergen is a toggle button with emoji and label

2. Select allergen exclusions (e.g., nuts, gluten): ✅ UI IMPLEMENTED
   - Allergen toggles work correctly in the UI
   - Selected allergens highlighted with red border/background
   - State stored in excludeAllergens array: ['gluten', 'nuts', etc.]
   - ALLERGEN_OPTIONS (line 26-36) uses simple string IDs: { id: 'gluten', label: 'Gluten', emoji: '🌾' }

3. Generate meal plan: ❌ BUG - FILTER NOT WORKING
   - Frontend passes: excludeAllergenTagIds: ['gluten', 'nuts'] (string names)
   - Backend expects: excludeAllergenTagIds: ['clxyz123...', 'clxyz456...'] (CUID database IDs)
   - MISMATCH: Frontend allergen IDs do NOT match database allergen tag IDs

4. Verify no recipes contain excluded allergens: ❌ CANNOT WORK DUE TO BUG
   - Because the IDs don't match, the filter query finds zero matches
   - Prisma query: WHERE allergenTags.none.allergenTagId IN ['gluten', 'nuts']
   - Database allergenTagId values are CUIDs, not 'gluten', 'nuts'
   - Result: No allergens are excluded, all recipes pass through

5. Check ingredient lists for allergen ingredients: ❌ NOT EFFECTIVE

Root Cause Analysis:

CRITICAL BUG: ID/Name Mismatch Between Frontend and Backend

Frontend (MealPlanWizard.tsx:26-36):
```javascript
const ALLERGEN_OPTIONS = [
  { id: 'gluten', label: 'Gluten', emoji: '🌾' },  // Uses name as ID
  { id: 'dairy', label: 'Dairy', emoji: '🧀' },
  ...
];
```

Database (schema.prisma:436-446):
```
model AllergenTag {
  id          String  @id @default(cuid())  // Auto-generated CUID like 'clxyz123...'
  name        String  @unique               // 'gluten', 'dairy', etc.
  ...
}
```

Seed (seed.ts:420-426):
```javascript
prisma.allergenTag.create({
  data: { name },  // Creates tag with CUID id, allergen name in 'name' field
})
```

Repository (recipes.ts:377-383):
```javascript
where.allergenTags = {
  none: {
    allergenTagId: { in: filters.excludeAllergenTagIds },  // Expects CUIDs, receives names
  },
};
```

Recommended Fixes:

Option A: Lookup allergen tag IDs by name in planGenerator before passing to repository
  - Add: const tagIds = await prisma.allergenTag.findMany({ where: { name: { in: excludeAllergenTagIds } } })
  - Pass: tagIds.map(t => t.id) to repository

Option B: Change repository to filter by allergenTag.name instead of allergenTagId
  - Modify where clause: allergenTags: { none: { allergenTag: { name: { in: filters.excludeAllergenTagIds } } } }

Option C: Make frontend fetch allergen tags from API with actual IDs (adds complexity, network request)

Code Issues Found:
- CRITICAL BUG: Allergen exclusion filter is completely broken due to ID mismatch
  Frontend passes allergen names ('gluten', 'dairy') but repository filters by database IDs (CUIDs)
  The filter query will never match any recipes, effectively doing nothing
- This is a silent failure - no error thrown, filter just doesn't work
- User thinks allergens are excluded but they are NOT

Additional Observations:
- The dietTagIds filter would have the same issue if it were used from the UI
- The repository's buildWhereClause correctly implements the filtering logic
- The bug is in the data contract between frontend and backend
- No unit or integration tests caught this because they'd need to test with real DB IDs
- The UI correctly shows selected allergens with visual feedback (red styling)
- Allergen tags ARE properly created in seed data and linked to recipes

Impact:
- HIGH SEVERITY: Users with allergies may receive recipes containing allergens they tried to exclude
- This is a potential safety issue for users with food allergies

Verdict: FAIL (CRITICAL BUG: Allergen exclusion filter completely non-functional due to frontend passing allergen names while backend expects database CUID IDs)
================================================================================

================================================================================
Test: PLAN-007 - Edge case: No matching recipes shows helpful error
Date: 2026-01-05T23:45:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/services/planGenerator.ts - Error codes and messages (lines 7-24, 111-126, 153-158)
- apps/web/src/server/api/routers/plan.ts - Error mapping to tRPC codes (lines 10-17, 72-109)
- apps/web/src/app/planner/page.tsx - Frontend error display (lines 145-190)

Test Step Analysis:

1. Navigate to /planner: ✅ IMPLEMENTED
   - MealPlanWizard renders with all filter options
   - User can enable multiple dietary restrictions and filters

2. Enable all dietary restrictions: ✅ CAN BE DONE
   - isVegetarian toggle available
   - isDairyFree toggle available
   - Advanced filters collapsible section with allergens

3. Select all allergen exclusions: ⚠️ CAN BE DONE (but PLAN-006 bug makes it ineffective)
   - 9 allergen toggles available: gluten, dairy, eggs, nuts, peanuts, soy, shellfish, fish, sesame
   - NOTE: Due to bug in PLAN-006, allergen filtering doesn't actually work

4. Set maximum cook time very low: ✅ CAN BE DONE
   - Time dropdown has "15 min or less" option (TIME_OPTIONS[0])
   - Combined with EASY difficulty would further restrict

5. Attempt to generate plan: ✅ IMPLEMENTED
   - Form submits to plan.generate mutation

6. Verify helpful error message about no matching recipes: ✅ IMPLEMENTED

Error Flow Analysis:

Backend Error Codes (planGenerator.ts:7-13):
- NO_RECIPES_AVAILABLE: "No recipes available. Please seed the database first."
- NO_RECIPES_MATCH_PREFERENCES: "No recipes match your preferences. Please adjust and try again."
- NO_RECIPES_FOR_MEAL_TYPE: "No recipes available for {mealType}. Please add more recipes to the database."

Error Mapping (plan.ts:10-17):
- NO_RECIPES_AVAILABLE → BAD_REQUEST (400)
- NO_RECIPES_MATCH_PREFERENCES → BAD_REQUEST (400)
- NO_RECIPES_FOR_MEAL_TYPE → BAD_REQUEST (400)

Error Trigger Points:
1. Line 111-116: Thrown when recipesMatchingDiet.length === 0 (dietary/time filters too restrictive)
2. Line 121-126: Thrown when eligibleRecipes.length === 0 (dislikes filtered everything out)
3. Line 153-158: Thrown when no recipes for specific meal type (e.g., no breakfast recipes)

Frontend Error Display (planner/page.tsx:145-190):
- Amber-themed error card with X icon
- Title: "We hit a snag generating your plan"
- Message: Displays error.message from tRPC error
  * For NO_RECIPES_MATCH_PREFERENCES: "No recipes match your preferences. Please adjust and try again."
  * For NO_RECIPES_FOR_MEAL_TYPE: "No recipes available for {mealType}. Please add more recipes..."
- Fallback message: "This is usually temporary. Check your connection and try again in a moment."
- Two buttons: "Go Back" (to /dashboard) and "Try Again" (resets to wizard)

7. Verify suggestions to relax filters: ❌ NOT IMPLEMENTED
   - Error messages do not provide specific suggestions
   - "Please adjust and try again" is vague
   - Does NOT suggest which specific filters to relax
   - Does NOT show which filters were most restrictive
   - Does NOT highlight that combining vegetarian + dairy-free + time limit may be too restrictive

Missing Suggestions Functionality:
- No indication of how many recipes matched each filter stage
- No "These filters reduced your options from 30 → 5 → 0" feedback
- No "Try relaxing: dairy-free filter (would add 8 more recipes)" suggestions
- No link back to wizard with current filters pre-populated

Code Issues Found:
- ISSUE: Error messages are generic and don't help users understand which filter to relax
  * "No recipes match your preferences" doesn't tell user WHICH preference is problematic
  * User has to guess which of 5+ filters is causing the issue
- ISSUE: No filter-by-filter recipe count feedback during or after filtering
- ISSUE: "Try Again" button resets ALL filters rather than keeping user's selections

Positive Observations:
- Error state is visually distinct and user-friendly
- "Try Again" option is prominently displayed
- "Go Back" option allows escape to dashboard
- Error message from backend is properly displayed to user
- No stack traces or technical errors exposed to user

Edge Case Scenarios Tested (via code review):

Scenario A: All filters ON (veg + dairy-free + 15min + EASY + all allergens)
- isVegetarian=true filters first (via Prisma query)
- isDairyFree=true filters second (via Prisma query)
- difficulty=EASY filters (via Prisma query)
- maxTotalTime=15 filters (via Prisma query)
- excludeAllergenTagIds ignored due to bug (no filtering)
- dislikes filters last (in-memory)
- If 0 recipes remain after Prisma query → NO_RECIPES_AVAILABLE or NO_RECIPES_MATCH_PREFERENCES
- If 0 recipes for meal type → NO_RECIPES_FOR_MEAL_TYPE

Scenario B: Dislikes too restrictive
- 30 recipes pass dietary filters
- User enters "chicken, beef, pork, salmon, vegetables, pasta, rice" as dislikes
- filterRecipesByDislikes filters all 30 recipes → 0 remain
- Throws NO_RECIPES_MATCH_PREFERENCES
- Error: "No recipes match your preferences. Please adjust and try again."

Verdict: FAIL (Error message is displayed but provides no helpful suggestions about which filters to relax; test step 7 "Verify suggestions to relax filters" is not implemented)
================================================================================

================================================================================
Test: PLAN-008 - Servings adjustment scales ingredient quantities
Date: 2026-01-06T00:15:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - householdSize input (lines 53, 349-368)
- apps/web/src/server/api/routers/plan.ts - API accepts householdSize (line 26, 45)
- apps/web/src/server/services/planGenerator.ts - Sets servings on MealPlanItem (lines 64, 180)
- apps/web/prisma/schema.prisma - MealPlanItem.servings field (line 307), Recipe.servingsDefault field (line 152)
- apps/web/src/server/services/shoppingList.ts - Uses servings for quantity scaling (lines 85-90)
- apps/web/src/components/features/recipe/RecipeDetailModal.tsx - Ingredient display (lines 153, 278-294)
- apps/web/src/components/features/recipe/RecipeCard.tsx - Stats display (lines 85, 210)
- apps/web/src/app/_components/MealPlanView.tsx - Recipe detail handling

Test Step Analysis:

1. Generate meal plan with household size 2: ✅ IMPLEMENTED
   - MealPlanWizard.tsx:53 - householdSize default is 2
   - MealPlanWizard.tsx:349-368 - Dropdown for household size (1-6 people)
   - planGenerator.ts:64 - householdSize default is 2
   - planGenerator.ts:180 - MealPlanItem.servings = householdSize

2. View a recipe in the plan: ✅ IMPLEMENTED
   - RecipeCard.tsx displays recipe in plan
   - onClick opens RecipeDetailModal
   - item (including servings) passed to modal

3. Verify ingredient quantities are for 2 servings: ❌ BUG - NOT SCALED
   - RecipeDetailModal.tsx:153 extracts `servings` from item
   - RecipeDetailModal.tsx:278-294 displays ingredients
   - Line 286: `{ri.quantity} {ri.unit}` shows ORIGINAL recipe quantity
   - NO SCALING applied based on servings vs recipe.servingsDefault
   - Example: Recipe with servingsDefault=4, user has servings=2
     * Should show HALF the original quantity
     * Actually shows the FULL original quantity

4. Generate another plan with household size 4: ✅ CAN BE DONE
   - User can select 4 from household size dropdown

5. Verify same recipe shows doubled quantities: ❌ BUG - NOT SCALED
   - Same issue as step 3
   - Ingredient quantities are NOT scaled in the recipe detail view
   - Always shows the recipe's original quantities (for servingsDefault)

Data Model Analysis:

Schema (schema.prisma):
- Recipe.servingsDefault (line 152): Default serving size for recipe (usually 4)
- MealPlanItem.servings (line 307): User's requested servings (householdSize)
- RecipeIngredient.quantity (line 275): Ingredient quantity for servingsDefault

Shopping List - CORRECTLY SCALES (shoppingList.ts:85-90):
```javascript
const { recipe, servings } = item;
const servingsMultiplier = servings / recipe.servingsDefault;
// ...
const adjustedQuantity = quantity * servingsMultiplier;
```
This is the CORRECT implementation that RecipeDetailModal should follow.

Recipe Detail Modal - DOES NOT SCALE (RecipeDetailModal.tsx:278-294):
```javascript
{recipe.ingredients.map((ri) => (
  <span className="ml-2 text-sm text-gray-600">
    {ri.quantity} {ri.unit}  // ← BUG: No scaling!
  </span>
))}
```
Missing: const scaledQuantity = ri.quantity * (servings / recipe.servingsDefault);

Recipe Card Stats - CORRECTLY SHOWS SERVINGS (RecipeCard.tsx:210):
```javascript
<span>{servings} servings</span>  // Shows user's requested servings
```
But ingredient preview (lines 25-31) shows names only, not quantities.

What Currently Works:
✅ Household size is captured from wizard
✅ Servings stored in MealPlanItem (equals householdSize)
✅ Servings displayed in recipe stats (RecipeCard, RecipeDetailModal)
✅ Shopping list quantities are correctly scaled
✅ Total calories scaled in nutritional info (line 317: recipe.calories * servings)

What Does NOT Work:
❌ Recipe ingredient quantities in RecipeDetailModal are NOT scaled
❌ Users see original recipe quantities regardless of their household size
❌ Recipe for 4 shows "2 cups rice" even when cooking for 2 (should show "1 cup rice")

Nutritional Calculation Shows Awareness of Issue:
RecipeDetailModal.tsx:316-317 correctly calculates:
```javascript
<p>Per serving: {recipe.calories} kcal</p>
<p>Total for this meal: {recipe.calories * servings} kcal</p>
```
This shows the developers understand scaling but forgot to apply it to ingredients.

Code Issues Found:
- CRITICAL BUG: Ingredient quantities not scaled by servings in RecipeDetailModal
  * Line 286 displays raw ri.quantity without servings adjustment
  * Should be: {(ri.quantity * (servings / recipe.servingsDefault)).toFixed(1)} {ri.unit}
  * This means users cooking for 2 people see quantities for 4 people (or vice versa)
  * Could lead to over/under-portioned meals

Fix Required:
In RecipeDetailModal.tsx, add scaling calculation:
```javascript
const { recipe, mealType, servings } = item;
const scaleFactor = servings / recipe.servingsDefault;

// In render:
{recipe.ingredients.map((ri) => {
  const scaledQty = ri.quantity * scaleFactor;
  return (
    // ...
    <span className="ml-2 text-sm text-gray-600">
      {scaledQty % 1 === 0 ? scaledQty : scaledQty.toFixed(1)} {ri.unit}
    </span>
  );
})}
```

Also need to display scaling context:
- Show "(adjusted for {servings} servings)" or similar
- Or add a servings dropdown to let users adjust in real-time

Observations:
- Shopping list correctly scales, proving the pattern is understood
- Calorie calculation correctly scales, proving servings is accessible
- Only ingredient display was missed in the scaling implementation
- This is a UX issue that could lead to incorrect portion sizes
- Users relying on the displayed quantities will prepare wrong amounts

Verdict: FAIL (BUG: RecipeDetailModal displays original recipe quantities without scaling for user's household size. Shopping list scales correctly, but recipe detail view does not.)
================================================================================

================================================================================
Test: SHOP-001 - Shopping list generates correctly from meal plan
Date: 2026-01-06T01:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/services/shoppingList.ts - Core ShoppingListService with buildAndStoreForPlan, getForPlan methods
- apps/web/src/server/api/routers/shoppingList.ts - tRPC router with getForPlan, getForMealPlan, toggleItemChecked, exportCSV
- apps/web/src/server/api/routers/plan.ts - Auto-creates shopping list after plan generation (lines 62-69)
- apps/web/src/lib/unitConverter.ts - Unit conversion and aggregation utilities
- apps/web/src/lib/unitConverter.test.ts - 35 unit tests for conversion logic
- apps/web/src/components/features/shopping/ShoppingList.tsx - Frontend shopping list component
- apps/web/src/app/_components/ShoppingList.test.tsx - 4 unit tests for UI component
- apps/web/src/lib/categoryConfig.ts - Category ordering and display labels
- apps/web/prisma/schema.prisma - ShoppingList and ShoppingListItem models (lines 329-356)

Test Step Analysis:

1. Generate a meal plan: ✅ IMPLEMENTED
   - plan.generate mutation auto-calls ShoppingListService.buildAndStoreForPlan (plan.ts:62-69)
   - Error in shopping list creation is logged but doesn't fail plan generation
   - Shopping list is persisted to database immediately after plan creation

2. Navigate to shopping list view: ✅ IMPLEMENTED
   - ShoppingList component fetches via api.shoppingList.getForPlan.useQuery
   - Authorization check: verifies plan.userId === session.user.id
   - Loading handled via tRPC query states

3. Verify all ingredients from plan recipes appear: ✅ IMPLEMENTED
   - shoppingList.ts:84-141 iterates through all plan items and their recipe ingredients
   - Every ingredient from every recipe in the plan is processed
   - ingredientMap tracks unique ingredients with quantities

4. Verify quantities are aggregated correctly: ✅ IMPLEMENTED
   - Servings multiplier applied: servingsMultiplier = servings / recipe.servingsDefault (line 86)
   - Same ingredient + same unit: quantities summed (lines 95-97)
   - Same ingredient + different convertible units: normalized and combined (lines 99-128)
   - Unit conversion via convertToNormalizedUnit() with proper multipliers
   - Final quantity rounded to 1 decimal: Math.round(item.quantity * 10) / 10 (line 151)

5. Verify units are normalized (g, ml, pcs): ✅ IMPLEMENTED
   - unitConverter.ts defines 3 normalized units: 'g' | 'ml' | 'pcs'
   - Weight: g, kg, oz, lb → g (grams)
   - Volume: ml, l, tsp, tbsp, cup, fl oz → ml (milliliters)
   - Count: pcs, pieces, count, whole → pcs (pieces)
   - Large quantities auto-formatted: 1500g → "1.5kg", 2500ml → "2.5L" (formatQuantity)

Unit Conversion Implementation (unitConverter.ts):
- kg → g: multiplier 1000
- oz → g: multiplier 28.35
- lb → g: multiplier 453.592
- l → ml: multiplier 1000
- tsp → ml: multiplier 5
- tbsp → ml: multiplier 15
- cup → ml: multiplier 240
- fl oz → ml: multiplier 29.5735

Aggregation Logic (shoppingList.ts:79-141):
1. Create ingredientMap to track unique ingredients
2. For each MealPlanItem:
   - Calculate servingsMultiplier = item.servings / recipe.servingsDefault
   - For each recipe ingredient:
     - adjustedQuantity = quantity * servingsMultiplier
     - Key: `${ingredient.id}-${unit}`
3. If same key exists: add quantities directly
4. If same ingredientId but different unit:
   - Attempt to normalize both to common unit
   - If units match after normalization, combine
   - Otherwise create separate entry
5. Store to database with rounded quantities

Edge Cases Handled:
- Empty plan: throws "Meal plan not found" error
- Same ingredient in multiple recipes: quantities summed
- Different units for same ingredient: normalized and combined when possible
- Incompatible unit types (g vs ml): kept as separate line items
- Database replication lag: retry logic (3 attempts with backoff)

Frontend Display (ShoppingList.tsx):
- Groups items by category (vegetables, fruits, protein, dairy, grains, pantry, other)
- Category order defined in CATEGORY_ORDER constant
- Accordion UI with expand/collapse per category
- Each item shows: quantity, unit, ingredient name
- Check/uncheck functionality with optimistic updates
- "Check All" / "Uncheck All" per category
- Premium users get "Compare Prices" button

Authorization (shoppingList.ts router):
- getForPlan: verifies plan.userId === session.user.id
- Protected procedures used for all endpoints

Test Coverage:
- unitConverter.test.ts: 35 tests covering all conversion rules, aggregation, formatting
- ShoppingList.test.tsx: 4 tests for toggle, category updates, optimistic revert, empty state

Code Issues Found:
- MINOR: Two different shopping list fetch methods exist:
  1. getForPlan - returns persisted ShoppingList entity
  2. getForMealPlan - re-computes from recipes, subtracts pantry items
  These could return different results if pantry changes. Potential confusion.

- MINOR: getForMealPlan considers pantry items but getForPlan doesn't
  If user has pantry items, the persisted shopping list won't reflect them
  But the dynamically generated one (getForMealPlan) will subtract pantry

- MINOR: No service-level tests for ShoppingListService
  Unit conversion is well-tested, but service integration is not

Observations:
- Shopping list generation is fully automatic and robust
- Unit normalization is comprehensive with proper multipliers
- Aggregation logic handles edge cases (different units, same ingredient)
- Frontend provides good UX with categories, toggle, optimistic updates
- Authorization properly prevents accessing other users' shopping lists
- Retry logic handles transient database issues
- The shopping list correctly scales quantities based on household size (servings)
- Integration with pantry exists but only in getForMealPlan, not persisted list

Verdict: PASS (code review confirms shopping list correctly generates with proper aggregation, unit normalization to g/ml/pcs, and quantity scaling by servings)
================================================================================

================================================================================
Test: SHOP-002 - Ingredient aggregation combines same ingredients
Date: 2026-01-06T02:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/services/shoppingList.ts - buildAndStoreForPlan aggregation logic (lines 78-141)
- apps/web/src/lib/unitConverter.ts - convertToNormalizedUnit and aggregateIngredients utilities
- apps/web/src/lib/unitConverter.test.ts - 35 unit tests covering conversion and aggregation
- apps/web/prisma/schema.prisma - RecipeIngredient.unit and ShoppingListItem models

Test Step Analysis:

1. Generate plan where multiple recipes use same ingredient: ✅ SCENARIO SUPPORTED
   - Common ingredients like olive oil, garlic, onion appear in many recipes
   - Seed data has ingredients used across multiple recipes
   - ShoppingListService.buildAndStoreForPlan processes all recipe ingredients

2. View shopping list: ✅ IMPLEMENTED
   - ShoppingList component fetches via api.shoppingList.getForPlan
   - Items grouped by category with quantities displayed

3. Verify ingredient appears only once: ✅ IMPLEMENTED
   - shoppingList.ts:79-82 uses Map keyed by `${ingredient.id}-${unit}`
   - Same ingredient with same unit gets the same key
   - Lines 95-97: `existing.quantity += adjustedQuantity` when key exists
   - Lines 99-128: Cross-unit normalization for same ingredient with different units

4. Verify quantity is sum of all recipe usages: ✅ IMPLEMENTED
   - Line 90: `adjustedQuantity = quantity * servingsMultiplier`
   - Line 97: `existing.quantity += adjustedQuantity` sums all usages
   - Final quantity rounded to 1 decimal: `Math.round(item.quantity * 10) / 10` (line 151)

5. Verify unit conversion is handled correctly: ✅ IMPLEMENTED
   - Lines 99-128: When same ingredient has different units:
     a. Both quantities converted to normalized unit via convertToNormalizedUnit()
     b. If normalized units match (both → g, both → ml, or both → pcs), quantities combined
     c. If incompatible (g vs ml), kept as separate entries (lines 124-127)
   - Conversion multipliers (unitConverter.ts:13-33):
     * Weight: kg→g (*1000), oz→g (*28.35), lb→g (*453.592)
     * Volume: l→ml (*1000), tsp→ml (*5), tbsp→ml (*15), cup→ml (*240), fl oz→ml (*29.5735)
     * Count: pieces, count, whole → pcs (*1)

Aggregation Algorithm Walkthrough:

Example: 3 recipes each use 200g olive oil (household size 2, recipe default 4)
- Recipe 1: 200g * (2/4) = 100g olive oil
- Recipe 2: 200g * (2/4) = 100g olive oil
- Recipe 3: 200g * (2/4) = 100g olive oil
- Result: 300g olive oil (one entry)

Example: 2 recipes use garlic, one in grams, one in pieces
- Recipe 1: 10g garlic
- Recipe 2: 2 pcs garlic
- Result: 2 separate entries (g vs pcs are incompatible types)
  * This is correct behavior - can't combine weight with count

Example: 2 recipes use milk in different volume units
- Recipe 1: 1 cup milk = 240ml
- Recipe 2: 500ml milk
- Result: 740ml milk (normalized and combined)

Unit Test Coverage (unitConverter.test.ts):
- 15 tests for convertToNormalizedUnit (all unit types, case-insensitivity, error handling)
- 8 tests for aggregateIngredients (single, multiple same, different, converted, incompatible)
- 12 tests for formatQuantity (kg/L scaling, rounding, pieces)
- Edge cases: empty array, whitespace trim, unknown units

Cross-Unit Normalization Logic (shoppingList.ts:99-128):
- Iterates existing items looking for same ingredientId
- Calls convertToNormalizedUnit() on both quantities
- If normalized units match, updates existing entry with combined normalized quantity
- Updates map key to reflect new normalized unit
- If units don't match, creates separate entry (fallback to line 131-138)

Potential Edge Case Issues (MINOR):

1. Map key update race condition potential (lines 117-120):
   - Old key deleted, new key set with same object
   - If multiple entries for same ingredient with different units are processed
     in sequence, this could cause unexpected behavior
   - BUT: Ingredients from same recipe can't have same ingredient twice,
     so in practice this only happens across recipes - should be fine

2. Unknown units not converted but stored (shoppingList.ts:124-127):
   - If a recipe has an unrecognized unit (e.g., "handful", "pinch")
   - convertToNormalizedUnit() throws, caught in try/catch
   - Entry created with original unit (line 131-138)
   - Result: "handful basil" and "2 pcs basil" would be separate entries
   - This is acceptable graceful degradation

3. Display formatting (formatQuantity):
   - Large quantities auto-scaled: 1500g → "1.5kg", 2500ml → "2.5L"
   - Pieces rounded to whole numbers
   - Non-normalized units stored as-is

Database Storage:
- ShoppingListItem.unit is String (not enum) - allows any unit
- ShoppingListItem.quantity is Float - supports decimal aggregation
- ingredientId links back to canonical ingredient for categorization

Code Issues Found:
- NONE - aggregation logic is robust and well-tested

Observations:
- Aggregation algorithm handles all common scenarios correctly
- Cross-unit conversion works for compatible unit types (weight→weight, volume→volume)
- Incompatible units gracefully kept separate (sensible behavior)
- Servings multiplier correctly applied before aggregation
- Comprehensive unit test coverage validates edge cases
- Round to 1 decimal prevents floating-point display issues
- Map-based aggregation is O(n) for n ingredients across all recipes

Verdict: PASS (code review confirms ingredient aggregation correctly combines same ingredients, handles unit conversion, and has comprehensive test coverage)
================================================================================

================================================================================
Test: SHOP-003 - CSV export downloads valid file
Date: 2026-01-06T03:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/export/shoppingListCsv.ts - CSV generation utility using csv-stringify/sync
- apps/web/src/app/api/plan/[id]/export/shopping-list/route.ts - HTTP API endpoint for CSV download
- apps/web/src/server/api/routers/shoppingList.ts - tRPC router with exportCSV query (lines 216-282)
- apps/web/src/components/features/plan/ExportButtons.tsx - Frontend export button component
- apps/web/src/lib/export/plan.ts - Export utility functions (filename generation, etc.)
- apps/web/src/server/api/routers/shoppingList.test.ts - Unit tests for CSV export

Test Step Analysis:

1. Generate meal plan with shopping list: ✅ PREREQUISITE
   - Shopping list auto-generated after plan creation (plan.ts:62-69)
   - ShoppingListService.buildAndStoreForPlan creates persisted list

2. Click CSV export button: ✅ IMPLEMENTED
   - ExportButtons.tsx:129-138 provides "Export CSV" button
   - onClick triggers handleExport('csv') function
   - Loading state shown: "Preparing..." while exporting
   - Button is visually distinct with secondary variant

3. Verify file downloads: ✅ IMPLEMENTED
   - ExportButtons.tsx:42-60 downloadBlob() function:
     a. Fetches GET /api/plan/[id]/export/shopping-list
     b. Converts response to Blob
     c. Creates temporary object URL
     d. Creates <a> element with download attribute
     e. Programmatically clicks to trigger download
     f. Cleans up object URL after download
   - Content-Disposition header: `attachment; filename="[filename]"` (route.ts:40)

4. Open CSV file: ✅ VALID CSV FORMAT
   - shoppingListCsv.ts uses csv-stringify/sync library (line 1)
   - Proper CSV escaping handled by library
   - Rows correctly comma-separated

5. Verify columns: Item, Quantity, Unit (+ Category, Checked): ✅ IMPLEMENTED
   - shoppingListCsv.ts:25-31 defines columns:
     * Item (ingredient name)
     * Quantity (rounded to 2 decimals)
     * Unit (g, ml, pcs, etc.)
     * Category (vegetables, protein, etc.)
     * Checked (yes/no based on item.checked boolean)
   - NOTE: Test says "ingredient, quantity, unit" but implementation has 5 columns
     This is BETTER than test specification (more useful data)

6. Verify all items from list are in CSV: ✅ IMPLEMENTED
   - route.ts:23-32: Fetches getForPlan, maps all items to CSV format
   - All shopping list items included without filtering

CSV Generation Flow (HTTP API endpoint - primary):
1. ExportButtons calls GET /api/plan/[id]/export/shopping-list
2. route.ts:14-48 handles request:
   - Creates tRPC context from request headers (session auth)
   - Fetches plan via trpc.plan.getById (validates ownership)
   - Fetches shopping list via trpc.shoppingList.getForPlan
   - Calls generateShoppingListCsv() with item data
   - Returns Response with Content-Type: text/csv, Content-Disposition: attachment
3. Browser triggers download due to Content-Disposition header

Alternative tRPC Export (not used by UI):
- shoppingListRouter.exportCSV (lines 216-282) returns { csv: string }
- Manually constructs CSV without library (line 266-278)
- Different column order: Category, Ingredient, Quantity, Unit
- NOTE: This endpoint exists but UI uses the HTTP API endpoint instead

Filename Generation:
- createShoppingListCsvFilename(startDate, days) → shoppingListCsv.ts:35-37
- Uses createPlanFilename('shopping-list', startDate, days, 'csv') from plan.ts
- Format: "shopping-list-YYYYMMDD.csv" (e.g., "shopping-list-20260106.csv")
- ExportButtons also generates filename: `shopping-list-${dateSegment}.csv` (line 83)
  where dateSegment is like "jan6" or "jan6-12" for ranges

Unit Test Coverage (shoppingList.test.ts:147-242):
- Test: "should export shopping list as CSV" (lines 148-207)
  * Verifies CSV contains header row: "Category,Ingredient,Quantity,Unit"
  * Verifies data row includes: "protein,chicken breast"
  * Uses mock meal plan with known ingredients
- Test: "should not allow export of another user's meal plan" (lines 209-231)
  * Verifies authorization check
- Test: "should require authentication" (lines 233-241)
  * Verifies unauthenticated access denied

DISCREPANCY: Two different CSV implementations exist:
1. HTTP API (route.ts + shoppingListCsv.ts):
   - Columns: Item, Quantity, Unit, Category, Checked
   - Uses csv-stringify/sync for proper escaping
   - This is what the UI button calls
2. tRPC (shoppingList.ts:exportCSV):
   - Columns: Category, Ingredient, Quantity, Unit
   - Manually builds CSV string (no escaping library)
   - Not used by UI, only in tests

The HTTP API implementation is more robust:
- Uses proper CSV library for escaping special characters
- Includes "Checked" column for tracking progress
- Properly handles Content-Disposition for browser download

Error Handling:
- route.ts:44-47: Catches errors, logs to console, returns 500 JSON error
- ExportButtons.tsx:85-91: Catches download errors, shows user-friendly message
  "Unable to export CSV right now. Please try again."

Code Issues Found:
- MINOR: Two different CSV export implementations with different column orders
  * tRPC exportCSV uses: Category, Ingredient, Quantity, Unit (4 columns)
  * HTTP API uses: Item, Quantity, Unit, Category, Checked (5 columns)
  * The tRPC version constructs CSV manually without proper escaping:
    `csv += \`${ingredient.category},${ingredient.name},...\n\``
    If ingredient name contains comma, the CSV will be malformed
  * RECOMMENDATION: Remove tRPC exportCSV or update to use csv-stringify

- MINOR: tRPC exportCSV not used by UI but has unit tests
  * Tests verify tRPC endpoint works
  * UI uses HTTP API endpoint instead
  * Potential confusion/maintenance burden

- MINOR: No test for actual file download behavior
  * Unit tests verify CSV string content
  * No integration test for browser download flow
  * Would require E2E testing framework (Playwright/Cypress)

Observations:
- Primary CSV export (HTTP API) is well-implemented with proper library
- File downloads work via blob + programmatic link click pattern
- Filename is descriptive and date-based
- CSV includes useful columns beyond test specification (Category, Checked)
- Quantity is rounded to 2 decimal places for readability
- Authorization properly checked before export
- Loading state provides user feedback during export

Verdict: PASS (code review confirms CSV export downloads valid file with proper columns, authorization, and error handling via HTTP API endpoint)
================================================================================

================================================================================
Test: SHOP-004 - Price comparison shows supermarket prices (premium)
Date: 2026-01-06T04:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/features/shopping/ShoppingList.tsx - ShoppingList component with "Compare Prices" button (lines 290-301)
- apps/web/src/components/features/dashboard/PremiumPreviewModal.tsx - Modal showing sample price comparison data
- apps/web/src/server/api/routers/shoppingList.ts - getForMealPlan with storePrices calculation (lines 150-187)
- apps/web/src/server/api/routers/shoppingList.test.ts - Unit tests confirming storePrices API
- apps/web/prisma/schema.prisma - PriceBaseline model (lines 358-369)
- apps/web/prisma/price-baselines.json - Baseline prices for Aldi, Lidl, Tesco, Dunnes
- apps/web/src/mockData/stores.json - Static mock data used in PremiumPreviewModal
- apps/web/src/app/plan/[id]/page.tsx - Plan page that renders ShoppingList WITHOUT onComparePrices prop

Test Step Analysis:

1. Sign in as premium user: ✅ POSSIBLE
   - premium@example.com / P@ssw0rd! (role: premium) available in seed data

2. Generate meal plan: ✅ IMPLEMENTED
   - plan.generate works for premium users
   - Shopping list auto-created after plan generation

3. View shopping list: ✅ IMPLEMENTED
   - ShoppingList component renders on /plan/[id] page
   - Items grouped by category with check/uncheck functionality

4. Verify price comparison data is displayed: ❌ NOT DISPLAYED FOR PREMIUM USERS
   - CRITICAL BUG: ShoppingList on plan page is rendered WITHOUT onComparePrices prop
   - plan/[id]/page.tsx:94 - `<ShoppingList planId={id} />` (no onComparePrices)
   - Without onComparePrices prop, the "Compare Prices" button is NOT rendered
   - The button logic at ShoppingList.tsx:290: `{onComparePrices && (...)}` never shows

5. Verify Aldi, Lidl, Tesco, Dunnes prices shown: ❌ NOT SHOWN
   - PriceBaseline data exists in DB with 4 stores: Aldi, Lidl, Tesco, Dunnes
   - getForMealPlan API correctly calculates storePrices from PriceBaseline
   - BUT: UI never calls getForMealPlan - only calls getForPlan (which doesn't return prices)
   - PremiumPreviewModal uses STATIC mock data (stores.json), not real prices

6. Verify cheapest option is highlighted: ❌ NOT IMPLEMENTED FOR REAL DATA
   - getForMealPlan returns cheapestStore with lowest price
   - PremiumPreviewModal uses isCheapest flag from static mock data
   - No UI component connects getForMealPlan to premium user price display

Architecture Analysis:

BACKEND - Price Calculation EXISTS (shoppingList.ts:150-187):
- getForMealPlan API fetches PriceBaseline from database
- Calculates per-store totals based on ingredient categories
- Returns storePrices array sorted by price (cheapest first)
- Returns cheapestStore with store name and total
- Unit tested and working correctly

DATABASE - PriceBaseline data EXISTS (price-baselines.json):
- 5 categories: protein, vegetables, dairy, grains, pantry
- 4 stores: Aldi, Lidl, Tesco, Dunnes
- Prices per gram stored in database
- NOTE: Missing fruits category - would need to be added

FRONTEND - Premium Price Comparison NOT CONNECTED:

Problem 1: ShoppingList rendered without onComparePrices
- plan/[id]/page.tsx:94 - No onComparePrices prop passed
- Button never appears, even for premium users
- Fix: Need to pass onComparePrices callback and modal state

Problem 2: No component to display REAL prices for premium users
- PremiumPreviewModal uses STATIC mock data (stores.json)
- Shows hardcoded Lidl: €42.60, Tesco: €47.80, Dunnes: €45.30, SuperValu: €48.50
- These are NOT from database or user's actual shopping list
- Badge says "Example with Sample Data" even for premium users

Problem 3: getForMealPlan never called in UI
- The API exists to calculate real prices
- No frontend component calls this API
- Need: Premium-only component that fetches getForMealPlan and displays real data

Problem 4: Free vs Premium tier not differentiated
- ShoppingList.tsx:293 shows different button text based on isPremium
- BUT: Button only appears if onComparePrices prop is passed (which it isn't)
- Both free and premium users see same experience (no price button)

What Would Be Needed to Make This Work:

1. In plan/[id]/page.tsx:
   - Add state: const [showPriceModal, setShowPriceModal] = useState(false);
   - Pass prop: <ShoppingList planId={id} onComparePrices={() => setShowPriceModal(true)} />
   - Add modal: <PriceComparisonModal open={showPriceModal} onOpenChange={setShowPriceModal} planId={id} />

2. Create new PriceComparisonModal for premium users:
   - Call api.shoppingList.getForMealPlan.useQuery({ mealPlanId: planId })
   - Display storePrices with real data
   - Highlight cheapestStore

3. Keep PremiumPreviewModal for free users:
   - Shows sample data as teaser
   - CTA to upgrade to premium

4. Conditionally render modal based on isPremium:
   - Premium: Show real prices from getForMealPlan
   - Free: Show sample data with upgrade prompt

Code Issues Found:
- CRITICAL BUG: Price comparison feature is completely disconnected from UI
  * Backend API works (getForMealPlan returns real prices)
  * Frontend button not rendered (onComparePrices prop never passed)
  * Premium users see same experience as free users (nothing)
  * PremiumPreviewModal shows only MOCK data, never REAL prices

- MISSING: Premium-specific price comparison component
  * PremiumPreviewModal is for FREE users (shows sample data)
  * No equivalent component for PREMIUM users with real prices

- MISSING: Integration between ShoppingList and price comparison modal
  * plan/[id]/page.tsx doesn't import or render any price modal
  * No state management for modal visibility

Unit Test Observations (shoppingList.test.ts):
- Tests verify getForMealPlan returns storePrices array
- Tests verify cheapestStore is calculated correctly
- Tests pass, confirming backend works
- No frontend/integration tests for price comparison UI

Observations:
- The backend infrastructure for price comparison is fully implemented and tested
- The frontend "Compare Prices" button exists but is never rendered
- Premium vs Free tier distinction is handled in button text but button never shown
- PremiumPreviewModal explicitly says "Example with Sample Data" - it's designed for free users
- This is a significant feature gap for premium users - they pay for price comparison but don't get it
- The feature was likely planned but not fully wired up in the UI

Verdict: FAIL (CRITICAL: Price comparison feature completely non-functional. Backend API works but is never called from UI. "Compare Prices" button not rendered. Premium users cannot see supermarket prices despite being a premium feature.)
================================================================================

================================================================================
Test: EXPORT-001 - PDF export generates downloadable meal plan
Date: 2026-01-05T12:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/api/plan/[id]/export/pdf/route.ts - HTTP API endpoint for PDF download (37 lines)
- apps/web/src/server/export/mealPlanPdf.tsx - PDF document generation using @react-pdf/renderer (216 lines)
- apps/web/src/components/features/plan/ExportButtons.tsx - UI buttons for PDF/CSV export (159 lines)
- apps/web/src/lib/export/plan.ts - Plan normalization and utility functions (397 lines)
- apps/web/src/lib/export/plan.test.ts - Unit tests for export utilities (105 lines)
- apps/web/src/app/plan/[id]/page.tsx - Plan page that integrates ExportButtons (102 lines)

Architecture Analysis:

1. API ENDPOINT (route.ts):
   - GET /api/plan/[id]/export/pdf
   - Authenticates via createTRPCContext (requires valid session)
   - Fetches plan via trpc.plan.getById (enforces user authorization)
   - Normalizes plan data via normalizeMealPlanForExport
   - Generates PDF via generateMealPlanPdf with user's name
   - Returns binary PDF with proper headers:
     * Content-Type: application/pdf
     * Content-Disposition: attachment; filename="..."
     * Cache-Control: no-store
   - Error handling returns 500 JSON with generic message (no stack traces)

2. PDF GENERATION (mealPlanPdf.tsx):
   - Uses @react-pdf/renderer v4.3.1 (latest stable)
   - MealPlanPdfDocument React component builds PDF structure
   - A4 page size with 32px padding
   - Helvetica font (PDF-safe, no font loading issues)
   - Structured content:
     * Header: "Weekly Meal Plan" title with date range and user name
     * Days: Each day on separate page (break={index !== 0})
     * Recipes: Card-style layout with badges (time, calories, diet tags)
     * Ingredients: Bulleted list with formatted quantities
     * Steps: Numbered list (max 6 steps via getInstructionsFromRecipe)
   - renderToBuffer creates binary PDF buffer

3. UI COMPONENT (ExportButtons.tsx):
   - Three buttons: "Export PDF", "Export CSV", "Print"
   - PDF button calls handleExport('pdf')
   - Loading state shows "Generating..." during download
   - Error state shows "Unable to generate PDF right now. Please try again."
   - downloadBlob utility:
     * Fetches PDF from API endpoint
     * Creates blob URL
     * Programmatically clicks download link
     * Cleans up blob URL after download
   - Filename: meal-plan-{dateSegment}.pdf (e.g., "meal-plan-jan6-12.pdf")

4. INTEGRATION (page.tsx):
   - ExportButtons rendered in plan header section (line 78)
   - Receives planId, planStartDateIso, planDays props
   - Visible to authenticated users viewing their plans

Test Step Verification:

1. "Generate a meal plan" - ✅ PREREQUISITE
   - Plan generation works (verified in PLAN-001)
   - Plan page accessible at /plan/[id]

2. "Click PDF export/download button" - ✅ IMPLEMENTED
   - Button visible in ExportButtons component (lines 119-128)
   - Icon: FileText from lucide-react
   - Text: "Export PDF" (or "Generating..." when loading)
   - onClick triggers handleExport('pdf')

3. "Verify PDF file downloads" - ✅ IMPLEMENTED
   - downloadBlob function creates temporary anchor element
   - Sets link.download = filename for browser download behavior
   - Browser downloads file to Downloads folder
   - Content-Disposition header set as "attachment"

4. "Open PDF and verify content" - ✅ IMPLEMENTED
   - PDF document structure verified in mealPlanPdf.tsx:
     * Document > Page > Views/Text components
     * Valid PDF binary from renderToBuffer
     * Content-Type: application/pdf ensures proper handling

5. "Verify all 7 days and meals are included" - ✅ IMPLEMENTED
   - groupPlanByDay creates array of length plan.days
   - days.map iterates through all days
   - day.items.map iterates through all meals per day
   - Page breaks between days for readability
   - Day title shows "Day N · {date in full format}"

6. "Verify recipe details are readable" - ✅ IMPLEMENTED
   - Recipe title in bold (fontWeight: 600)
   - Badges show: cooking time, calories, vegetarian/dairy-free tags
   - Ingredients section with bulleted list
   - Steps section with numbered instructions (up to 6)
   - Servings shown in recipe header

Code Quality Analysis:

STRENGTHS:
- Clean separation of concerns (API, generation, UI components)
- Proper error handling at all layers
- Loading states provide user feedback
- PDF styling is production-quality (proper fonts, spacing, colors)
- Unit tests cover export utility functions
- Authorization enforced via tRPC context
- No sensitive data exposed in error messages

SECURITY:
- Session required to access PDF endpoint
- Plan ownership verified via trpc.plan.getById (throws if not owner)
- Generic error message hides implementation details
- No XSS risk (PDF generation is server-side)

AREAS FOR IMPROVEMENT (Minor):
- No direct unit test for PDF generation (mealPlanPdf.tsx)
  * Would require mocking @react-pdf/renderer
  * Integration test would be ideal but complex
- Filename uses client-side date formatting, API uses server-side
  * Slight inconsistency: client "meal-plan-jan6-12.pdf" vs server prefix with username
  * Not a bug, just cosmetic difference
- No test for actual download behavior (would need E2E)

Unit Test Coverage:
- plan.test.ts verifies:
  * normalizeMealPlanForExport normalizes dates and ingredients
  * groupPlanByDay creates correct structure with meal ordering
  * summarizeInstructions limits steps correctly
  * createPlanFilename produces expected format
- No mealPlanPdf.test.ts exists (PDF generation untested directly)

API Tests (if applicable):
- Cannot test via curl without valid session token
- API endpoint follows proper authentication flow
- Would need to:
  1. Sign in to get session cookie
  2. Generate/get valid plan ID
  3. Call GET /api/plan/{id}/export/pdf with cookie
  4. Verify response is valid PDF binary

Observations:
- PDF export is fully implemented and production-ready
- Uses industry-standard @react-pdf/renderer library
- Document structure is professional with proper styling
- All 7 days included with page breaks between days
- Recipe details comprehensive: title, time, calories, diet badges, ingredients, steps
- Error handling is user-friendly without exposing internals
- Loading state provides feedback during generation
- Download behavior follows standard browser patterns
- Authorization properly enforced at API level
- Only missing: direct unit test for PDF component (not a blocker)

Verdict: PASS (code review confirms PDF export generates valid downloadable PDF with all required content - 7 days, all meals, recipe details are included and readable)
================================================================================

================================================================================
Test: EXPORT-002 - Print view renders correctly
Date: 2026-01-05T16:45:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/plan/[id]/print/page.tsx - Main print page component
- apps/web/src/app/_components/PrintAutoTrigger.tsx - Auto-triggers browser print dialog
- apps/web/src/components/features/plan/ExportButtons.tsx - Print button implementation
- apps/web/src/styles/globals.css - Print media query styles
- apps/web/src/app/layout.tsx - Root layout includes ConditionalHeader
- apps/web/src/app/_components/ConditionalHeader.tsx - Header visibility logic
- apps/web/src/components/layout/Header.tsx - Navigation header component

Code Issues Found:
1. **BUG: Header visible in print view** - The ConditionalHeader only hides the header on 
   landing page ("/"), auth pages ("/auth/"), and planner wizard ("/planner"). The print 
   view path "/plan/[id]/print" does NOT match any of these patterns, so the full 
   navigation header (logo, Dashboard link, user email, Sign out button) WILL be displayed
   when printing. This violates test step 5: "Verify no navigation/UI elements in print view"

2. The Header component at src/components/layout/Header.tsx lacks a "no-print" CSS class
   that would hide it from print output. Even if the header is rendered, it should be 
   hidden via @media print styles.

Test Step Verification:

1. "Generate a meal plan" - ✅ PREREQUISITE
   - Print view accessed via /plan/[id]/print
   - User must have an existing plan

2. "Navigate to print view (/plan/[id]/print)" - ✅ IMPLEMENTED
   - Route exists at apps/web/src/app/plan/[id]/print/page.tsx
   - ExportButtons has "Print" button (line 140-149) that opens print URL
   - Uses window.open with _blank target

3. "Verify layout is print-optimized" - ✅ PARTIAL
   - Print page uses white background (bg-white)
   - Simple typography with good contrast (text-gray-900)
   - Grid layout for ingredients/steps (md:grid-cols-2)
   - Reasonable max-width (max-w-5xl)
   - print:shadow-none removes box shadows for cleaner output
   - PrintAutoTrigger auto-calls window.print() after 250ms delay
   - ISSUE: Navigation header will print (see issue #1 above)

4. "Verify page breaks are sensible" - ✅ IMPLEMENTED
   - Each day article has "break-inside-avoid" class (line 92)
   - Shopping list section has "break-before-page" class (line 163)
   - globals.css defines print media query for these classes (lines 207-215):
     * break-before-page: break-before: page; page-break-before: always;
     * break-inside-avoid: break-inside: avoid; page-break-inside: avoid;
   - Prevents splitting meal content across pages

5. "Verify no navigation/UI elements in print view" - ❌ FAIL
   - The "← Back to interactive view" link has "no-print" class (line 78-85) ✓
   - The "Printing tips" section has "no-print" class (line 71-76) ✓
   - **BUG**: Header navigation WILL print - ConditionalHeader.tsx shows header 
     on print routes (only hides on "/", "/auth/*", "/planner")
   - Header component lacks "no-print" class to hide it via CSS media query
   - User will see: MealMind logo, Dashboard link, email, Sign out button in printout

Print Page Features Working:
- All days displayed with date headers
- All meals shown with: recipe title, meal type, servings, cook time, calories, diet tags
- Ingredients list with bullet points
- Recipe steps with numbered instructions (up to 8 steps)
- Shopping list organized by category on separate page
- Printing tips shown on screen but hidden when printing
- Back link shown on screen but hidden when printing
- Auto-triggers browser print dialog

API Tests (if applicable):
- N/A - Print view is a client-side rendering feature
- Page requires authentication (redirect to /auth/signin if no session)
- Plan ownership verified via trpc.plan.getById

Observations:
- Print page implementation is well-structured with proper print-specific CSS
- Good use of semantic HTML (main, header, section, article)
- Shopping list is helpfully included on a separate page
- The PrintAutoTrigger is a nice UX touch (auto-opens print dialog)
- Page breaks are thoughtfully placed to avoid splitting content
- CRITICAL: Navigation header will appear at top of every printed page
- This is a simple fix: add "no-print" class to <nav> in Header.tsx OR 
  add print path to ConditionalHeader's hideHeader check

Verdict: FAIL (BUG: Navigation header visible in print output. ConditionalHeader does not hide header on print routes, and Header component lacks no-print class. Test step 5 "Verify no navigation/UI elements in print view" fails.)
================================================================================

================================================================================
Test: UI-001 - Landing page renders all sections correctly
Date: 2026-01-05T17:30:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/page.tsx - Main landing page structure
- apps/web/src/components/features/landing/Hero.tsx - Hero section component
- apps/web/src/components/features/landing/HeroImage.tsx - Hero background image
- apps/web/src/components/features/landing/FeatureCards.tsx - Features section
- apps/web/src/components/features/landing/Pricing.tsx - Pricing section
- apps/web/src/components/features/landing/Testimonials.tsx - Testimonials section
- apps/web/src/components/features/landing/CTA.tsx - CTA section and Footer
- apps/web/src/styles/globals.css - Global styles and CSS variables

Test Step Verification:

1. "Navigate to / (home)" - ✅ Route exists
   - page.tsx renders 5 main sections in order
   - Clean component structure: Hero → FeatureCards → Pricing → Testimonials → CTA

2. "Verify hero section with CTA" - ✅ IMPLEMENTED
   - Hero component (Hero.tsx) renders:
     * Full-width section with emerald gradient background
     * Background image via HeroImage component with fallback to Unsplash
     * Main heading: "Your Family, Fed and Happy"
     * Subheading with value proposition
     * Two CTAs: "Start Planning Free" (primary) and "Sign In" (secondary/ghost)
   - Links correctly point to /auth/signup and /auth/signin

3. "Verify features section displays all features" - ✅ IMPLEMENTED
   - FeatureCards component (FeatureCards.tsx) renders:
     * Section title: "Everything you need for happier mealtimes"
     * 4 feature cards in responsive grid (1-2-4 columns)
     * Each card has: icon, title, description
     * 2 cards marked as "Premium" with lock icon badge
     * Features: meal planning, shopping lists, price comparison, preferences
   - Icons from Lucide React (CalendarDays, ShoppingCart, Euro, Settings)
   - Hover effects: shadow-lg, translateY, scale

4. "Verify pricing section shows both tiers" - ✅ IMPLEMENTED
   - Pricing component (Pricing.tsx) renders:
     * Section title: "Choose what works for your family"
     * Monthly/Annual billing toggle with "Save X%" badge
     * Two pricing tiers: Free and Premium
     * Premium highlighted with "Most Popular" badge
     * Feature lists with checkmarks for each tier
     * CTAs: "Get Started" (Free) and "Go Premium" (Premium)
     * Trust signals for Premium: money-back guarantee, cancel anytime
     * Value comparison to meal kit services
   - Uses PRICING constants from @meal-planner-demo/constants

5. "Verify testimonials section" - ✅ IMPLEMENTED
   - Testimonials component (Testimonials.tsx) renders:
     * Section title: "Real Irish families, real results"
     * 3 testimonial cards in responsive grid
     * Each card has: star rating, quote, author info, avatar, proof metrics
     * "Verified household" badges
     * Location-specific (Cork, Dublin, Galway)
   - Uses Next.js Image for optimized avatar loading

6. "Verify footer with links" - ✅ IMPLEMENTED
   - CTA component (CTA.tsx) includes footer:
     * Final CTA section with emerald gradient and radial pattern
     * Footer with 3 navigation links: About, Contact, Privacy
     * Copyright notice with dynamic year
     * Links have adequate touch target (min-h-[44px])

Code Quality Analysis:

STRENGTHS:
- Clean component separation with single responsibility
- Proper TypeScript interfaces for data structures
- Responsive design with Tailwind breakpoints (sm/lg)
- Accessibility: aria-hidden on decorative elements, semantic HTML
- Optimized images via Next.js Image component with blur placeholder
- CSS variables for theme consistency (emerald color palette)
- Good animation support via custom keyframes in globals.css
- Proper error handling with fallback image in HeroImage

DESIGN QUALITY ASSESSMENT (per frontend-design skill guidelines):

1. Typography:
   - Font: Geist Sans (var(--font-geist-sans)) - A distinctive, modern font
   - ✅ NOT using generic fonts (Inter, Roboto, Arial)
   - Good hierarchy: text-4xl/5xl headings, text-lg/xl body

2. Color & Theme:
   - ✅ Cohesive emerald palette (emerald-50 through emerald-950)
   - ✅ CSS variables for consistency (oklch color format)
   - ✅ Accent colors purposeful: amber for premium badges, blue for shopping
   - ❌ CONCERN: Gradients are somewhat predictable (emerald gradients on white)
       Not as egregious as "purple gradients on white" but still follows a pattern

3. Motion:
   - ✅ Custom animations defined (fade-in, scale-in, slide-in)
   - ✅ Hover states with transitions (shadow-lg, translateY, scale)
   - ✅ Respects prefers-reduced-motion accessibility
   - ❌ MISSING: No entry animations on scroll or page load
       Cards could benefit from staggered reveal animations

4. Spatial Composition:
   - ❌ PREDICTABLE: Standard grid layouts (1x, 2x, 3x, 4x columns)
   - ❌ No asymmetry, overlap, or grid-breaking elements
   - ❌ Very conventional "marketing page" layout pattern
   - Max-width containers create same boring structure

5. Visual Details & Atmosphere:
   - ✅ Hero has background image with gradient overlay
   - ✅ Pricing has decorative blur elements for depth
   - ✅ CTA has radial gradient pattern
   - ❌ Testimonials/Features sections are relatively flat
   - ❌ No textures, noise, or grain overlays
   - ❌ No decorative borders or custom cursors

DESIGN ISSUES (per "AI slop" criteria):

1. **Predictable layout pattern** - Standard SaaS landing page structure
   - Hero → Features → Pricing → Testimonials → CTA → Footer
   - Every section follows the same max-w-7xl centered pattern
   - No creative layout choices or asymmetry

2. **Cookie-cutter component patterns**:
   - Feature cards are identical card grids (very common)
   - Pricing table is standard two-column comparison
   - Testimonials are typical avatar + quote cards

3. **Timid color choices**: While emerald is cohesive, the overall
   palette is safe and predictable. No bold contrasts or unexpected
   color moments.

4. **Lack of distinctive visual identity**: Nothing memorable or
   unexpected that would make this page stand out. Feels like a
   template-based design.

5. **No meaningful animations on load**: Pages should have staggered
   reveal animations for engagement. Currently static on load.

SPECIFIC IMPROVEMENTS NEEDED FOR PRODUCTION POLISH:

1. ADD entry animations - staggered reveals on page load
2. BREAK the grid occasionally - asymmetric layouts, overlapping elements
3. ADD texture/atmosphere - subtle noise, grain, or pattern overlays
4. USE bolder typography moments - display font for hero, varied weights
5. CREATE visual "moments" - one memorable design element per section
6. ADD parallax or scroll-triggered effects for depth
7. CONSIDER darker color scheme for more impact (emerald-950 base)
8. ADD micro-interactions beyond basic hover states

Observations:
- All required sections ARE present and render correctly
- Component structure is clean and maintainable
- From a FUNCTIONAL perspective, the landing page is complete
- From a DESIGN QUALITY perspective, it needs significant polish
- The page would pass basic QA but wouldn't win design awards
- Follows "safe" SaaS landing page conventions too closely
- Need to add more distinctive visual character for production

Verdict: PASS (All sections render correctly as specified in test steps. The page is functionally complete with Hero+CTA, Features, Pricing (both tiers), Testimonials, and Footer. However, design polish is needed for production - noted as recommendations, not blockers.)
================================================================================

================================================================================
Test: UI-002 - Mobile responsive design works on all pages
Date: 2026-01-05T18:30:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/layout.tsx - Root layout with html h-full scroll-smooth
- apps/web/src/components/layout/Header.tsx - Mobile menu Sheet, hamburger button
- apps/web/src/styles/globals.css - @media queries, animations, prefers-reduced-motion
- apps/web/src/components/features/landing/Hero.tsx - Responsive typography/spacing
- apps/web/src/components/features/landing/Pricing.tsx - Responsive grid lg:grid-cols-2
- apps/web/src/components/features/landing/FeatureCards.tsx - 1/2/4 column grid
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Full-screen mobile modal
- apps/web/src/app/dashboard/_components/DashboardClient.tsx - Responsive grids/buttons
- apps/web/src/components/features/shopping/ShoppingList.tsx - Touch-friendly items
- apps/web/src/app/auth/signin/page.tsx - Responsive form layout
- apps/web/src/components/ui/button.tsx - min-h-[44px] touch targets

Test Step Analysis:

1. "Set viewport to mobile size (375px)" - ✅ CODE SUPPORTS MOBILE
   - Tailwind breakpoints used consistently: sm:, md:, lg:
   - Base styles target mobile-first, breakpoints add desktop enhancements
   - No fixed-width containers that would break on small screens

2. "Navigate through all main pages" - ✅ RESPONSIVE PATTERNS IMPLEMENTED
   
   Landing Page (page.tsx):
   - Hero: px-6, py-16 (compact on mobile), sm:py-20, lg:py-24
   - Features: grid-cols-1 → sm:grid-cols-2 → lg:grid-cols-4
   - Pricing: grid-cols-1 → lg:grid-cols-2
   - Text: text-4xl → sm:text-5xl headings
   
   Dashboard (DashboardClient.tsx):
   - Hero: px-8 py-10 → sm:px-12 (comfortable padding)
   - Quick Actions: gap-6 sm:grid-cols-2 lg:grid-cols-3
   - CTAs: flex-col → sm:flex-row with w-full → sm:w-auto
   - Premium Features: lg:grid-cols-2
   
   Planner Wizard (MealPlanWizard.tsx):
   - Mobile: Full-screen modal (h-full w-full rounded-none)
   - Desktop: Centered dialog (sm:max-w-lg sm:rounded-2xl)
   - Sticky header for mobile navigation
   - Forms: Full-width on mobile with proper padding
   
   Shopping List (ShoppingList.tsx):
   - Accordion items: rounded-2xl → sm:rounded-xl
   - Items: py-4 px-4 → sm:px-5
   - Checkboxes: h-12 w-12 (52px min) → sm:h-11 w-11 (48px min)

3. "Verify no horizontal scrolling" - ✅ IMPLEMENTED
   - html class="h-full scroll-smooth" for vertical scrolling only
   - max-w-7xl containers prevent overflow
   - px-4/px-6 consistent padding on all sections
   - No fixed-width elements > 100vw found
   - Only exception: PremiumPreviewModal table has overflow-x-auto (intentional for data tables)

4. "Verify touch targets are adequate size" - ✅ IMPLEMENTED (44-48px minimum)
   
   Touch target patterns found across 16 files (36 occurrences):
   - min-h-[44px]: Standard touch target (WCAG AAA compliant)
   - min-h-[48px]: Enhanced touch targets for critical actions
   
   Specific implementations:
   - Header.tsx: Desktop nav items min-h-[44px], mobile nav min-h-[48px]
   - ShoppingList.tsx: Checkbox buttons min-h-[52px] (extra large for easy tapping)
   - Button.tsx: Base button min-h-[44px] built into component
   - Auth forms: Submit buttons and links with min-h-[44px]
   - DashboardClient.tsx: CTA buttons min-h-[48px]
   - MealPlanWizard.tsx: Cancel button min-h-[44px]

5. "Verify text is readable without zooming" - ✅ IMPLEMENTED
   - Base text: text-base (16px) - mobile-friendly
   - Body text: text-sm (14px) to text-lg (18px) range
   - Input fields: text-base for better mobile input
   - No text smaller than 14px for body content
   - font-medium/font-semibold for readability

6. "Verify navigation works on mobile" - ✅ IMPLEMENTED
   
   Header.tsx Mobile Navigation:
   - Hamburger button visible on md:hidden
   - Sheet component slides in from right (side="right")
   - Menu items: min-h-[48px] with hover:translate-x-1 feedback
   - User info displayed in emerald card
   - Sign out button full-width
   - Sheet auto-closes on navigation (onClick → setMobileMenuOpen(false))
   - Animation delay on menu items for staggered effect
   - Proper focus management with SheetTitle (sr-only)

Mobile-Specific Features Implemented:
- Full-width buttons on mobile (w-full sm:w-auto pattern)
- Stack → row layout transitions (flex-col sm:flex-row)
- Larger padding/margins for touch (py-4 sm:py-3)
- Rounded corners adjusted for mobile (rounded-2xl → sm:rounded-xl)
- Safe area considerations via sticky headers

Accessibility for Mobile:
- touch-manipulation: Not explicitly set (Tailwind's reset handles this)
- prefers-reduced-motion: ✅ Respected in globals.css (animation-duration: 0.01ms)
- aria-label on hamburger menu: ✅ "Toggle menu"
- Sheet title: sr-only for screen readers

Code Issues Found:
- MINOR: No explicit viewport meta tag in layout.tsx
  Next.js adds this automatically, but it's implicit
  Recommended: <meta name="viewport" content="width=device-width, initial-scale=1" />

- MINOR: PremiumPreviewModal table may require horizontal scrolling on very narrow screens
  This is acceptable UX for data tables but could be improved with responsive table design

- NOTE: Touch targets are excellent (44-52px), exceeding WCAG AA (44px) requirements

- NOTE: Some mobile-specific interactions could be enhanced:
  * No pull-to-refresh patterns
  * No swipe gestures for navigation
  * No bottom sheet patterns for actions
  These are enhancements, not requirements

Responsive Breakpoint Usage Summary:
- sm: 640px - Tablet portrait
- md: 768px - Tablet landscape (Header switches to desktop nav here)
- lg: 1024px - Desktop
- Consistent usage across all components

Observations:
- Mobile-first design philosophy correctly applied
- Tailwind responsive utilities used consistently
- Touch targets exceed WCAG AA requirements (44px min → actually 44-52px)
- Navigation properly converts to hamburger menu on mobile
- Forms are full-width on mobile with proper padding
- Text remains readable without zooming
- No horizontal scroll issues detected in code review
- Sheet/modal patterns work well for mobile overlays
- Sticky headers provide navigation context on long pages

Verdict: PASS (Code review confirms comprehensive mobile responsive design with proper touch targets, readable text, no horizontal scrolling, and working mobile navigation. All test steps verified through code analysis.)
================================================================================

================================================================================
Test: UI-003 - Loading states are shown during async operations
Date: 2026-01-05T16:30:00+00:00
Status: PASS
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/planner/page.tsx - Comprehensive loading state with animated spinner, rotating messages, progress bar
- apps/web/src/app/plan/[id]/loading.tsx - Next.js loading file with custom animated cooking icon
- apps/web/src/app/auth/signin/page.tsx - Button with loading spinner and text change during auth
- apps/web/src/app/auth/signup/page.tsx - Multi-step form with loading state on submit
- apps/web/src/app/auth/forgot-password/page.tsx - "Sending..." text during reset request
- apps/web/src/app/auth/reset-password/page.tsx - "Resetting password..." during mutation, Suspense fallback
- apps/web/src/components/features/shopping/ShoppingList.tsx - Uses isLoading from session status
- apps/web/src/components/ui/skeleton.tsx - Skeleton component available for loading states

Test Step Analysis:

1. "Generate a meal plan - Verify loading indicator appears during generation" - ✅ IMPLEMENTED
   - planner/page.tsx lines 90-115: Full-screen loading state with:
     * Animated spinner with ping effect (h-20 w-20 animate-ping)
     * Spinning border circle (animate-spin rounded-full border-4)
     * LOADING_MESSAGES array with 5 rotating messages (2s interval)
     * Progress bar animation (animate-progress)
     * "This takes about 10 seconds" feedback
   - lines 117-143: Success state with checkmark animation before redirect
   - lines 145-190: Error state with friendly message and retry button

2. "Navigate to dashboard - Verify loading state while data fetches" - ✅ IMPLEMENTED (via RSC)
   - Dashboard uses React Server Components with await api.mealPlan.getCurrent()
   - Next.js handles loading states at framework level
   - NOTE: No explicit loading.tsx for /dashboard route
   - Auth pages use Suspense with custom fallback spinners

3. "Check all form submissions show loading state" - ✅ IMPLEMENTED
   
   Sign In (signin/page.tsx):
   - lines 159-181: Button with disabled={loading}, aria-busy={loading}
   - Animated spinner SVG appears when loading=true
   - Button text changes: "Sign in" → "Signing you in..."
   - animate-pulse class added during loading
   
   Sign Up (signup/page.tsx):
   - lines 484-508: Button with disabled={loading}, aria-busy={loading}
   - Same spinner pattern as sign-in
   - primaryButtonLabel dynamically shows "Setting up your meal plan..."
   
   Forgot Password (forgot-password/page.tsx):
   - line 136-139: Button disabled when isPending
   - Text changes: "Send reset link" → "Sending..."
   
   Reset Password (reset-password/page.tsx):
   - lines 244-250: Button disabled when isPending
   - Text changes: "Reset password" → "Resetting password..."
   - lines 166-172: Loading state for token verification

Loading State Patterns Used:
1. Local state (loading/setLoading) for form submissions
2. TanStack Query isPending for tRPC mutations
3. Next.js Suspense with fallback for route-level loading
4. useSession() status === 'loading' for auth state
5. Custom loading.tsx file for Next.js route segments

Design Quality Assessment (per frontend-design skill):
- ✅ Motion: Animated spinners with spin/ping/pulse effects
- ✅ Progress feedback: Progress bar with gradient animation
- ✅ Contextual messages: Rotating messages give personality
- ✅ Success celebration: Checkmark animation before redirect
- ✅ Error recovery: Clear error states with retry actions
- NOT generic: Custom cooking icon in loading.tsx, emerald color scheme
- NOT "AI slop": Distinctive gradients (emerald-50 via-white to-amber-50)

Minor Issues Found:
1. ShoppingList.tsx line 42-44: No explicit loading skeleton while shoppingList query is loading
   The component jumps straight to empty state or content without intermediate loading
   
2. No loading.tsx for /dashboard route - relies on RSC suspense boundaries
   This is acceptable but could cause slight flash if API is slow

3. Skeleton component exists but is not widely used for content loading

Code Quality Notes:
- Loading states follow consistent pattern across auth forms
- Button states include both visual (spinner) and semantic (aria-busy) indicators
- Disabled states prevent double-submission
- Error states allow retry without losing context
- Progress feedback is time-aware ("This takes about 10 seconds")

Observations:
- The meal plan generation loading experience is particularly well-designed with:
  * Animated icons with shadow effects
  * Rotating encouraging messages
  * Animated progress bar
  * Success celebration before redirect
- Form submissions consistently show spinner + text change pattern
- auth pages use Suspense with styled fallbacks (spinner + text)
- The overall loading UX is production-ready and polished

Verdict: PASS (Comprehensive loading states implemented across all key async operations with good design quality. Minor improvements possible for shopping list loading and dashboard route.)
================================================================================

================================================================================
Test: UI-004 - Error states display helpful messages
Date: 2026-01-05T17:00:00+00:00
Status: PASS
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/plan/[id]/error.tsx - Next.js error boundary with user-friendly messaging
- apps/web/src/app/auth/signin/page.tsx - Form error handling with inline alerts
- apps/web/src/app/auth/signup/page.tsx - Comprehensive validation error display
- apps/web/src/app/auth/forgot-password/page.tsx - tRPC error handling
- apps/web/src/app/planner/page.tsx - Plan generation error state
- apps/web/src/app/_components/PlanPageClient.tsx - Regeneration error/success messages
- apps/web/src/components/features/plan/ExportButtons.tsx - Export error messages
- apps/web/src/components/features/recipe/RecipeDetailModal.tsx - Swap recipe error with Alert component
- apps/web/src/components/ui/alert.tsx - Alert variants for different error types

Test Step Analysis:

1. "Trigger network error (disconnect) - Verify error message is user-friendly" - ✅ IMPLEMENTED
   
   Sign In (signin/page.tsx lines 40-44):
   - Catches network errors with: "We couldn't sign you in right now. Check your connection and try again in a moment."
   - No technical details exposed to user
   
   Sign Up (signup/page.tsx lines 123-127):
   - Network error: "We hit a snag creating your account. Please check your connection and try again. If this keeps happening, we'll sort it out—just let us know."
   - Friendly, conversational tone without exposing stack traces
   
   Plan Generation (planner/page.tsx lines 145-190):
   - Full-page error state with amber styling
   - Friendly heading: "We hit a snag generating your plan"
   - Message: shows error.message OR "This is usually temporary. Check your connection and try again in a moment."
   - Go Back and Try Again buttons for recovery

2. "Trigger validation errors on forms - Verify field-level error messages" - ✅ IMPLEMENTED
   
   Sign Up Validation (signup/page.tsx):
   - Field-level errors at lines 426-430 (name), 448-452 (email), 470-474 (password)
   - Each field shows its own error message directly below the input
   - Uses role="alert" for accessibility
   - Errors parsed from server response (lines 102-110)
   - Clear on field change (lines 139-145)
   
   Password hints (line 475-477):
   - "Must be at least 8 characters with one uppercase letter and one number"
   
   Payment validation (lines 402-406):
   - Shows specific payment field errors

3. "Trigger server error - Verify generic error is shown without stack trace" - ✅ IMPLEMENTED
   
   Next.js Error Boundary (plan/[id]/error.tsx):
   - User-friendly heading: "Oops! We hit a snag"
   - Helpful message: "We couldn't load your meal plan this time. Don't worry — your data is safe."
   - Technical details COLLAPSED in <details> element (lines 39-46)
     - Only shows error.message, not full stack trace
     - Hidden by default so users don't see confusing info
   - Helpful suggestions section with recovery tips (lines 49-64)
   - Clear action buttons: "← Go Back" and "Try Again" (lines 68-81)
   
   tRPC Errors:
   - PlanPageClient.tsx (lines 77-82): Shows error with "Error:" prefix
   - ExportButtons.tsx (lines 87-91): Context-specific messages like "Unable to generate PDF right now. Please try again."
   - RecipeDetailModal.tsx (lines 266-272): Uses Alert component with "Unable to swap recipe" title

Error State Design Patterns Found:

1. **Alert Styling** (alert.tsx):
   - Consistent variant system: default, destructive, success, warning, info
   - Uses rounded-xl borders, proper contrast ratios
   - Icon support with proper positioning
   
2. **Form-Level Errors**:
   - Amber/yellow styling for warnings (border-amber-200 bg-amber-50)
   - Icon + message pattern with gap-3 layout
   - role="alert" and aria-live="polite" for accessibility
   
3. **Error Messages**:
   - Conversational, friendly tone ("We hit a snag", "Don't worry")
   - No technical jargon or error codes exposed
   - Always provide recovery actions (retry, go back, try again)
   
4. **No Stack Traces Exposed**:
   - error.tsx uses <details> to collapse technical info
   - Console.error for developer debugging only
   - Generic fallback messages when specific error unknown

Design Quality Assessment (per frontend-design skill):

✅ **Not AI Slop**: 
- Error states use consistent emerald/amber brand colors
- Custom icons and styling, not generic alerts
- Helpful suggestions box with bullet points in error.tsx
- Conversational copy that matches app personality

✅ **Visual Hierarchy**:
- Clear heading → description → action buttons flow
- Icon prominence draws attention
- Proper color coding (amber for warning, red for destructive)

✅ **Motion & Animation**:
- animate-fade-in on error boundary
- Smooth transitions on buttons
- Ring-1 ring-gray-100 for subtle depth

Minor Issues Found:

1. **No Global Root Error Boundary**: 
   - Only apps/web/src/app/plan/[id]/error.tsx exists
   - Other routes would show default Next.js error page
   - RECOMMENDATION: Add apps/web/src/app/error.tsx for global coverage

2. **Inconsistent Error Styling**:
   - Most forms use amber-50/amber-200 (warning style)
   - PlanPageClient uses red-50/red-200 (destructive style)
   - forgot-password uses red-50 without icon
   - RECOMMENDATION: Standardize on Alert component or single pattern

3. **No Toast Notifications**:
   - No toast/sonner library integrated
   - Errors show inline only
   - Some actions (export success) might benefit from toasts
   - NOTE: This is addressed in UI-005 test

4. **Print View Error** (ExportButtons line 104-106):
   - Pop-up blocked error shows as: "Please allow pop-ups to open the print view."
   - This is user-friendly but uses setErrorMessage which shows in a different location than button

Code Quality Notes:
- Consistent use of role="alert" for accessibility
- aria-live="polite" ensures screen readers announce errors
- Error states provide clear recovery actions
- Technical details hidden from users but available for debugging

Observations:
- Error handling is comprehensive across auth, plan generation, and export flows
- Messages are friendly and conversational, not robotic
- The error boundary in plan/[id]/error.tsx is particularly well-designed with:
  * Friendly icon and heading
  * Collapsible technical details
  * Helpful suggestions list
  * Multiple recovery actions
- Form validation errors appear immediately below fields
- No stack traces or sensitive info exposed to users

Verdict: PASS (Error states display helpful, user-friendly messages throughout the application. Technical details are hidden from users. All forms show field-level validation errors. Recovery actions are always provided. Minor inconsistencies in styling across different error types could be unified, but overall implementation is production-ready.)
================================================================================

================================================================================
Test: UI-005 - Toast notifications appear for user actions
Date: 2026-01-05T18:15:00+00:00
Status: FAIL
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/package.json - No toast library (sonner, react-hot-toast, etc.) installed
- apps/web/src/components/ui/alert.tsx - Static inline alerts only, no toast system
- apps/web/src/components/features/plan/ExportButtons.tsx - Uses inline error state only
- apps/web/src/app/_components/PlanPageClient.tsx - Uses inline success/error alerts
- apps/web/src/components/features/recipe/RecipeDetailModal.tsx - Uses browser alert() for clipboard copy
- apps/web/src/app/contact/ContactForm.tsx - Uses browser alert() for demo message

Test Step Analysis:

1. "Complete successful actions (save, generate, etc.) - Verify success toasts appear" - ❌ NOT IMPLEMENTED
   
   Current Implementation:
   - Plan regeneration (PlanPageClient.tsx lines 85-88): Uses INLINE alert that stays on page
     - "Plan regenerated successfully with your new filters!" in emerald-50 box
     - This is NOT a toast - it's a persistent inline message
   - Export success: No success feedback at all after PDF/CSV download completes
   - Recipe swap: No success toast, just closes modal
   - Sign up success: Redirects to dashboard, no toast
   - Sign in success: Redirects to dashboard, no toast
   
   What Should Happen:
   - Toast should appear at top-right or bottom-right
   - Should auto-dismiss after 3-5 seconds
   - Should provide non-blocking confirmation of action

2. "Verify toasts auto-dismiss" - ❌ NOT IMPLEMENTED
   
   No toast library installed. Current feedback methods:
   - Inline alerts (don't auto-dismiss)
   - Browser alert() dialogs (block user, require click)
   - Page redirects (lose context)

3. "Trigger error condition - Verify error toast appears with helpful message" - ❌ NOT IMPLEMENTED
   
   Current Error Handling (NOT toasts):
   - ExportButtons.tsx (lines 87-91, 151-153): Inline error text below buttons
   - PlanPageClient.tsx (lines 77-82): Inline error alert box
   - RecipeDetailModal.tsx (lines 266-272): Inline Alert component
   - Auth pages: Inline error messages near form fields
   
   These are INLINE MESSAGES, not toasts. They don't:
   - Appear in a consistent position
   - Auto-dismiss
   - Stack when multiple errors occur

Code Issues Found:

1. **No Toast Library Installed**
   - package.json has no toast dependencies (sonner, react-hot-toast, react-toastify)
   - Need to install: `pnpm add sonner` or similar
   
2. **Browser alert() Usage (Anti-Pattern)**
   - RecipeDetailModal.tsx line 139: `alert('Recipe link copied to clipboard!')`
   - ContactForm.tsx line 71: `alert('This is a demo form...')`
   - Browser alerts are blocking, ugly, and not branded
   - Should be replaced with toast notifications
   
3. **Missing Success Feedback**
   - PDF export success: No feedback (just downloads silently)
   - CSV export success: No feedback (just downloads silently)
   - Recipe swap success: No explicit confirmation
   - Preference save: No confirmation (not verified)
   
4. **Inconsistent Feedback Positioning**
   - PlanPageClient: Error/success appears between filter panel and meal plan
   - ExportButtons: Error appears at bottom of export card
   - RecipeDetailModal: Error appears inside modal
   - No consistent "notification zone" in the UI

Design Quality Assessment (per frontend-design skill):

❌ **AI Slop Pattern**: Browser alert() usage is the most generic possible solution
❌ **No Toast System**: Missing a fundamental UX pattern for modern web apps
❌ **Inconsistent Feedback**: Each component handles success/error differently
❌ **No Auto-Dismiss**: Users must manually acknowledge inline messages or they persist

Recommendations for Implementation:

1. Install sonner (recommended) or react-hot-toast:
   ```bash
   pnpm add sonner
   ```

2. Add Toaster provider to root layout:
   ```tsx
   import { Toaster } from 'sonner';
   // In layout: <Toaster position="top-right" richColors />
   ```

3. Replace browser alert() with toast():
   ```tsx
   import { toast } from 'sonner';
   // Instead of alert('Recipe link copied!')
   toast.success('Recipe link copied to clipboard!');
   ```

4. Add success toasts for key actions:
   - Plan generation complete
   - PDF/CSV export complete
   - Recipe swap complete
   - Preferences saved
   - Password reset email sent

5. Replace inline errors with error toasts for transient errors:
   ```tsx
   toast.error('Unable to generate PDF. Please try again.');
   ```

Observations:
- The app has no toast notification system whatsoever
- All feedback is either inline (persistent) or uses blocking browser dialogs
- This is a significant UX gap for a production application
- The existing Alert component is well-designed but is for inline use only
- Users get no ephemeral confirmation when actions complete successfully

Verdict: FAIL (No toast notification system implemented. Uses browser alert() in some places which is poor UX. Success feedback missing for most actions. Need to install toast library and add notifications across the app.)
================================================================================

================================================================================
Test: UI-006 - Navigation is consistent and intuitive
Date: 2026-01-05T19:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/layout/Header.tsx - Main navigation header with desktop/mobile variants
- apps/web/src/app/_components/ConditionalHeader.tsx - Header visibility logic by route
- apps/web/src/app/plan/[id]/page.tsx - Plan page with "Back to Dashboard" link
- apps/web/src/app/about/page.tsx - About page with "Back to Home" link
- apps/web/src/components/features/landing/CTA.tsx - Footer with navigation links
- apps/web/src/components/features/landing/Hero.tsx - Landing page hero (no logo visible)

Test Step Analysis:

1. "Check all navigation links work correctly" - ✅ IMPLEMENTED
   - Header.tsx: Dashboard link works correctly (line 41-44, 66-72)
   - Footer (CTA.tsx): About, Contact, Privacy links work (lines 38-55)
   - Back links on subpages: About, Contact, Privacy, Plan pages all have back links
   - Auth pages: Links between signin/signup/forgot-password work
   - Mobile navigation: Sheet menu with same links as desktop (lines 103-113)

2. "Verify active state on current page" - ❌ NOT IMPLEMENTED
   - Header.tsx navItems have NO active state indicator
   - Line 65-72: Link styling is static (text-gray-700)
   - No use of usePathname() to compare current route
   - No visual differentiation for active page
   - Missing: aria-current="page" for accessibility
   - Missing: Different color/weight/underline for current page

   Current navigation only has ONE item (Dashboard), so the issue isn't
   highly visible. However, if more nav items are added, users won't
   know which page they're on.

   Expected Implementation:
   ```tsx
   const pathname = usePathname();
   const isActive = pathname === item.href;
   // Apply: text-emerald-600 font-semibold or underline for active
   ```

3. "Verify back button behavior is sensible" - ⚠️ PARTIAL
   - Plan page: "Back to Dashboard" link → Goes to /dashboard ✅
   - About page: "← Back to Home" → Goes to / ✅
   - Print page: "← Back to interactive view" → Goes to /plan/[id] ✅
   - Auth pages: "Back to sign in" links work correctly ✅
   - ISSUE: No actual browser back button handling
     * Does not use router.back() anywhere (might break deep links)
     * All "back" links are hardcoded to specific destinations
     * This is acceptable but less flexible than true back navigation
   - ISSUE: No consistent back button pattern
     * Some pages use "← Back to X" (about, contact, privacy)
     * Some pages use "Back to Dashboard" without arrow (plan page)
     * Some pages have no back option (dashboard itself)

4. "Verify breadcrumbs (if present) are accurate" - ❌ NOT IMPLEMENTED
   - No breadcrumb component exists in the codebase
   - Grep for "breadcrumb" returns no results
   - For a meal planner app with multiple levels (Dashboard → Plan → Recipe),
     breadcrumbs would improve navigation
   - Example needed structure: Dashboard > Meal Plan > Day 3
   - Not strictly required, but would improve UX

5. "Check logo links to home" - ⚠️ PARTIALLY CORRECT
   - Header Logo (authenticated): Links to /dashboard (line 13-36)
   - Landing page: NO visible logo in header (header hidden via ConditionalHeader)
   - Footer: NO logo present
   - ISSUE: Logo links to /dashboard instead of /
     * This is technically correct for authenticated users
     * Most apps link logo to home (/) and have separate dashboard link
     * Current behavior is acceptable but unconventional
   - ConditionalHeader hides header on landing, auth, and planner pages
     * Users on "/" see no header at all (intentional marketing design)
     * Users on auth pages see no header

Navigation Consistency Analysis:

CONSISTENT PATTERNS:
✅ All internal links use Next.js Link component
✅ Mobile and desktop nav items match
✅ Touch targets are 44-48px (accessible)
✅ Hover states on all navigation links
✅ Focus visible states for keyboard navigation

INCONSISTENT PATTERNS:
❌ Back link styling varies between pages:
   - About: "← Back to Home" (emerald-600, no background)
   - Plan: "Back to Dashboard" (full button on mobile, text on desktop)
   - Print: "← Back to interactive view" (gray-600)

❌ Some pages have back links, others don't:
   - /dashboard: No back option (makes sense - it's the home base)
   - /plan/[id]: Has back to dashboard ✅
   - /about, /contact, /privacy: Have back to home ✅
   - /planner: No back option (modal covers full screen)

NAVIGATION UX ISSUES:

1. **No Active State**: Users cannot tell which page they're on from nav
   - Only 1 nav item currently (Dashboard), but problem if expanded
   - Should add visual indicator for current page

2. **Inconsistent Back Patterns**:
   - Mixed arrow vs no-arrow styling
   - Mixed button vs link styling
   - Should standardize on one pattern

3. **No Breadcrumbs**: Would help in deep navigation
   - Dashboard → Plan → Shopping List structure
   - Currently relies on back links only

4. **Logo Destination**: Links to /dashboard, not /
   - Unconventional but workable
   - Could confuse users expecting home page

Design Quality Assessment (per frontend-design skill):

STRENGTHS:
✅ Clean, minimal header design
✅ Mobile menu is well-executed (Sheet component, animations)
✅ Sufficient touch targets throughout
✅ Consistent emerald color theme

WEAKNESSES:
❌ Generic navigation pattern - nothing distinctive
❌ No creative navigation solutions (e.g., sticky nav with scroll effects)
❌ No micro-animations on nav item selection
❌ Missing active state is a basic UX oversight

Code Issues Found:
1. BUG: No active state indicator on navigation items
   - Users cannot see which page is currently active
   - Missing aria-current="page" for screen readers
   - Should use usePathname() to highlight current route

2. INCONSISTENCY: Back link styling varies between pages
   - Plan page: Full button on mobile, plain text on desktop
   - About/Contact/Privacy: Plain text with arrow
   - Should standardize back navigation pattern

3. MISSING: No breadcrumb navigation system
   - Would improve UX for multi-level navigation
   - Not blocking but recommended for production

Observations:
- Core navigation functions correctly (all links work)
- Mobile navigation is well-implemented with Sheet component
- Navigation is functional but lacks polish for production
- Active state is a basic UX pattern that should be implemented
- Breadcrumbs would help but aren't strictly required
- Logo linking to dashboard is acceptable for authenticated sections
- Footer navigation is minimal but sufficient (About, Contact, Privacy)

Verdict: FAIL (Missing active state indicator on navigation items - test step 2 fails. Users cannot tell which page is currently active from the navigation. This is a basic UX requirement. Also noted: inconsistent back link patterns and no breadcrumbs, but these are less critical.)
================================================================================
================================================================================
Test: PERF-001 - Initial page load is under 3 seconds
Date: 2026-01-05T14:30:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/layout.tsx - Root layout with providers
- apps/web/src/app/page.tsx - Landing page (5 sections: Hero, Features, Pricing, Testimonials, CTA)
- apps/web/next.config.js - Next.js configuration with standalone output
- apps/web/src/components/features/landing/HeroImage.tsx - Hero image with Next.js Image component
- apps/web/src/components/features/landing/FeatureCards.tsx - Feature cards section
- apps/web/src/components/features/landing/Pricing.tsx - Pricing section (client component)
- apps/web/src/styles/globals.css - CSS with Tailwind + custom animations

Performance Measurements (localhost development server):
- Connect time: 0.000166s
- Time to First Byte (TTFB): 57ms (0.057s) - EXCELLENT
- Total response time: 67ms (0.067s) - EXCELLENT
- HTML document size: 193KB (includes inline styles)
- CSS bundle size: ~135KB
- Hero image (original): 362KB JPG
- Hero image (optimized via Next.js): Uses responsive srcset with multiple sizes

Performance Analysis:

1. "Time to First Contentful Paint < 1.5s" - LIKELY PASS
   ✅ TTFB is 57ms (local dev server) - very fast
   ✅ Hero image has priority attribute for LCP optimization
   ✅ Hero image uses blur placeholder for perceived performance
   ✅ All scripts use async attribute (38 scripts async)
   ✅ Single CSS file loaded with appropriate precedence
   
   CONCERNS (may affect real-world FCP):
   - CSS bundle is 135KB - somewhat large but reasonable
   - No visible font preloading (uses system fonts via Geist fallback)
   - Development server metrics, production may differ

2. "Time to Interactive < 3s" - LIKELY PASS
   ✅ All scripts async-loaded (non-blocking)
   ✅ No blocking resources detected
   ✅ Client components (Pricing, PageTransition) are lightweight
   ✅ Uses React 19 with Next.js 15.5 (modern hydration)
   
   CONCERNS (may affect TTI):
   - tRPC client loaded on landing page (unused there)
   - Testimonials section has 3 external images (Unsplash)
   - PageTransition adds animation wrapper to all pages

3. "Check for render-blocking resources" - PASS
   ✅ CSS uses data-precedence for proper loading order
   ✅ All JS chunks loaded with async
   ✅ Preload used for HMR client (dev only)
   ✅ No inline <style> blocking tags
   ✅ No synchronous <script> tags

Image Optimization Analysis:
✅ Hero image:
   - Uses Next.js Image component with fill mode
   - Has priority attribute for LCP
   - Has blur placeholder (data URL)
   - Responsive srcset: 640w, 750w, 828w, 1080w, 1200w, 1920w, 2048w, 3840w
   - Quality set to 75 (reasonable compression)

✅ Testimonial avatars:
   - Use loading="lazy" for below-fold images
   - Small sizes (48x48) with 2x variants
   - Served via Next.js Image optimization

Font Loading Analysis:
- Uses --font-geist-sans CSS variable
- Falls back to system fonts (ui-sans-serif, system-ui)
- No Google Fonts or external font loading detected
- GOOD: System font stack means zero font load time

Bundle Analysis (Development):
- 38 async script chunks loaded
- Major chunks: react-dom, next internals, trpc client
- tRPC client included on landing page (unnecessary for static page)

Production Recommendations:
1. Consider code-splitting tRPC to exclude from landing page
2. Hero image could be converted to WebP/AVIF for 30-50% size reduction
3. Consider preloading hero image in <head> for faster LCP
4. Run Lighthouse in production build for accurate metrics

Code Issues Found:
1. MINOR: tRPC client bundle loaded on static landing page (could be code-split)
2. MINOR: Hero image is JPG (362KB) - could use next-gen format for smaller size
3. MINOR: No explicit preconnect for Unsplash images (testimonial avatars)

Observations:
- Development server metrics are excellent (<100ms total)
- Page structure is well-optimized for performance
- Next.js Image optimization properly configured
- All resources load asynchronously
- No render-blocking resources
- Font loading is optimal (system fonts)
- Static landing page with minimal client-side JS needed
- Blur placeholder provides good perceived performance

Note: Real-world metrics would require:
- Production build testing
- Lighthouse or Web Vitals measurement
- Testing on throttled connection (e.g., "Slow 3G")
- Geographic distribution testing

Verdict: PASS (Code review shows good performance practices. TTFB 57ms, all resources async, images optimized with Next.js Image, system fonts used. Cannot measure exact FCP/TTI without browser testing, but code analysis indicates targets should be met. Minor optimizations possible but not blocking.)
================================================================================

================================================================================
Test: PERF-002 - Meal plan generation completes within reasonable time
Date: 2026-01-05T15:00:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/api/routers/plan.ts - tRPC router handling generate mutation
- apps/web/src/server/services/planGenerator.ts - Core plan generation logic
- apps/web/src/server/services/shoppingList.ts - Shopping list creation after plan
- apps/web/src/server/repositories/recipes.ts - Recipe query repository
- apps/web/src/app/planner/page.tsx - Frontend UI with loading states

Performance Architecture Analysis:

1. Plan Generation Flow:
   a) Fetch user record (1 query)
   b) RecipeRepository.findForPlanning() - fetch all matching recipes with ingredients
   c) Filter by dislikes in-memory
   d) For each day × meal type: filter eligible recipes, shuffle, pick one
   e) Create meal plan with items in single $transaction
   f) Validate generated plan (1 additional query)
   g) ShoppingListService.buildAndStoreForPlan() - aggregate ingredients and store

2. Database Query Analysis:
   ✅ Uses efficient Prisma queries with proper WHERE clauses
   ✅ Batch creation via createMany in transaction
   ✅ Only includes necessary relations for planning (ingredients only)
   ⚠️ Full recipe table scanned for each generation (no pagination)
   ⚠️ Shopping list creation does retry loop (up to 3 attempts with delays)

3. Algorithm Complexity:
   - O(n) where n = number of recipes matching filters
   - For each day × meal: O(n) filter + O(n) shuffle
   - For 7 days × 3 meals = 21 iterations
   - Total: O(21n) = O(n) - linear complexity

4. UI Loading Experience:
   ✅ Shows rotating loading messages every 2 seconds
   ✅ Progress bar animation (10 second duration)
   ✅ States: loading → success animation → redirect
   ✅ Error handling with "Try Again" button
   ✅ Loading message explicitly says "This takes about 10 seconds"

5. Progress Indicator Implementation:
   ✅ Animated spinner with pulse effect
   ✅ CSS @keyframes progress animation (10s duration, ease-in-out)
   ✅ Progress bar fills over 10 seconds
   ✅ 5 rotating messages at 2-second intervals
   ⚠️ Progress bar is purely cosmetic (not tied to actual progress)

6. Performance Optimizations Present:
   ✅ Transaction batches all database writes
   ✅ createMany for bulk item creation
   ✅ Recipe filtering uses database WHERE, not in-memory for dietary filters
   ✅ Repository pattern with proper query building
   ✅ Lazy shopping list creation (errors don't fail the mutation)

7. Potential Performance Concerns:
   - Full recipe fetch on each generation (could be cached)
   - Shuffle algorithm runs on full filtered array
   - Validation query re-fetches plan items after creation
   - Shopping list retry loop adds up to 300ms delay on failure

API Test Observations (server running at localhost:3000):
- Server responds with 200 status
- Cannot test authenticated endpoints via curl without session cookie
- Code analysis suggests generation should complete well under 10 seconds for typical dataset

UI Loading Experience Quality:
✅ Multiple loading messages provide engagement during wait
✅ Progress bar gives visual feedback (even if not accurate)
✅ Success animation provides satisfying completion feedback
✅ Error state is user-friendly with actionable options
✅ 10-second expectation is set explicitly in the UI

Code Issues Found:
1. MINOR: Progress bar animation (10s) is hardcoded and doesn't match actual generation time
   - Could mismatch if generation is faster/slower than 10s
   - Consider using actual mutation state to update progress

2. MINOR: No timeout handling for the mutation
   - If generation hangs, user sees perpetual loading
   - Consider adding a client-side timeout with error message

3. MINOR: 2.5s delay after success before redirect (line 30-36)
   - Adds to perceived total time
   - Could be reduced to 1.5s for faster UX

4. MINOR: Recipe caching could improve repeat generations
   - Currently fetches all recipes on each generation
   - Could cache in-memory for session duration

Observations:
- Algorithm is efficient (linear complexity)
- Database operations are properly batched
- UI provides good feedback during generation
- 10-second expectation is reasonable for complex generation
- Progress indicator is present and engaging
- Real performance depends on recipe count in database
- Code is well-structured with proper separation of concerns

Test Step Analysis:
1. "Generate 7-day meal plan" - ✅ Route exists and handles 7-day plans
2. "Measure time from submit to plan display" - Cannot measure without browser
3. "Verify generation completes in < 10 seconds" - Code analysis suggests likely PASS
4. "Verify progress indicator during generation" - ✅ Progress bar + rotating messages present

Verdict: PASS (Code review shows well-optimized generation flow with O(n) complexity, proper database batching, and comprehensive progress indication. The 10-second loading indicator matches the documented expectation. Cannot measure exact time without authenticated session, but code analysis indicates the architecture supports reasonable generation times. Minor improvements possible but not blocking.)
================================================================================

================================================================================
Test: UI-005 - Toast notifications appear for user actions
Date: 2026-01-05T09:30:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/package.json - No toast library dependencies (sonner, react-hot-toast, etc.)
- apps/web/src/components/ui/alert.tsx - Alert component variants for inline messages
- apps/web/src/app/_components/PlanPageClient.tsx - Inline success/error messages (not toasts)
- apps/web/src/components/features/recipe/RecipeDetailModal.tsx - Alert component for swap errors
- apps/web/src/app/auth/reset-password/page.tsx - Success state via full page render change
- apps/web/src/app/auth/forgot-password/page.tsx - Success state via submitted flag
- apps/web/src/app/contact/ContactForm.tsx - Uses alert() for demo form (not a proper toast)
- apps/web/src/components/features/shopping/ShoppingList.tsx - No success feedback for toggle

Test Step Analysis:

1. "Complete successful actions (save, generate, etc.) - Verify success toasts appear" - ❌ NOT IMPLEMENTED

   Current Pattern Analysis:
   
   Plan Regeneration (PlanPageClient.tsx:85-89):
   - Shows INLINE success message: "Plan regenerated successfully with your new filters!"
   - Uses static div, NOT a toast that appears and auto-dismisses
   - Message persists until page interaction - not typical toast behavior
   
   Password Reset (reset-password/page.tsx):
   - Shows full-page success state with checkmark icon
   - Redirects to /auth/signin after 3 seconds
   - This is page-level state, not a toast notification
   
   Forgot Password (forgot-password/page.tsx):
   - Shows page-level "Check your email" success state
   - Replaces entire form with success message
   - Not a toast - full page transition
   
   Contact Form (ContactForm.tsx:69-72):
   - Uses browser alert(): "This is a demo form..."
   - NOT a proper toast - this is the browser's native alert dialog
   - Bad UX pattern - alerts block the main thread
   
   Shopping List Item Toggle:
   - Uses optimistic updates (ShoppingList.tsx:56-83)
   - NO visual feedback on success (no toast, no message)
   - Only shows error state via rollback on failure
   
   Recipe Swap:
   - Shows success implicitly via recipe change
   - Error shows via Alert component (RecipeDetailModal.tsx:266-272)
   - NO explicit success toast

2. "Verify toasts auto-dismiss" - ❌ NOT APPLICABLE
   - No toast implementation exists
   - Inline messages do NOT auto-dismiss (persist indefinitely)
   - PlanPageClient success message stays visible until mutation.reset() or navigation

3. "Trigger error condition - Verify error toast appears with helpful message" - ❌ NOT IMPLEMENTED
   - Errors show as INLINE elements, not toasts
   - PlanPageClient.tsx:77-82 - inline red div
   - RecipeDetailModal.tsx - Alert component
   - Export failures - setErrorMessage state, inline display
   - These are static messages, not animated appearing/disappearing toasts

Missing Toast System Architecture:

The application has NO toast notification system:

1. No toast library installed:
   - No sonner (shadcn/ui recommended)
   - No react-hot-toast
   - No react-toastify
   - No notistack

2. No Toaster provider in layout:
   - apps/web/src/app/layout.tsx does not include <Toaster /> component
   - No toast context provider wrapped around app

3. No useToast hook:
   - No custom hook for triggering toasts
   - No toast.success(), toast.error() helper functions

4. Current feedback patterns (NOT toasts):
   Pattern A: Inline messages (PlanPageClient)
   - Static <div> elements that appear on success/error
   - No auto-dismiss, no animation in/out
   
   Pattern B: Page-level state changes (auth pages)
   - Entire page content changes on success
   - Not a toast overlay
   
   Pattern C: Alert component (RecipeDetailModal)
   - Stays visible until user action
   - Part of page content, not floating overlay
   
   Pattern D: Browser alert() (ContactForm)
   - Blocking, modal dialog
   - Bad UX, not a toast

Actions Requiring Toast Notifications:

HIGH PRIORITY (user needs confirmation):
- ✗ Shopping list item checked/unchecked (no feedback currently)
- ✗ Recipe swapped successfully (implicit via UI change only)
- ✗ Plan regenerated (inline message, should be toast)
- ✗ CSV/PDF exported (inline message, should be toast)
- ✗ Link copied to clipboard (uses alert() - RecipeDetailModal:139)

MEDIUM PRIORITY:
- ✗ Preferences saved
- ✗ Profile updated

LOW PRIORITY (full-page transitions acceptable):
- Password reset success (redirects to login)
- Sign up success (shows celebration modal + redirect)

Implementation Recommendation:

To implement toasts, the application needs:

1. Install toast library:
   npm install sonner (recommended by shadcn/ui)

2. Add Toaster to layout.tsx:
   import { Toaster } from 'sonner'
   <Toaster richColors position="top-right" />

3. Replace alert() calls with toast():
   import { toast } from 'sonner'
   toast.success('Recipe link copied to clipboard!')

4. Add success toasts to mutations:
   onSuccess: () => {
     toast.success('Plan regenerated successfully!')
     // ... existing invalidation logic
   }

5. Replace inline error divs with toast.error():
   onError: (error) => {
     toast.error(error.message || 'Something went wrong')
   }

Code Issues Found:
- CRITICAL: No toast notification system exists in the application
- alert() used for clipboard copy feedback (RecipeDetailModal.tsx:139) - blocks UI thread
- Success feedback inconsistent: some actions show inline messages, others show nothing
- Error feedback is inline-only, no floating toast pattern
- Inline success messages don't auto-dismiss, can be confusing

Observations:
- The application uses Alert component for in-page status, but these are not toasts
- Toast notifications are a standard UX pattern for ephemeral feedback
- Current inline messages require user to scroll to see them if not in viewport
- Shopping list toggle has NO success feedback - users can't confirm action worked
- The alert() call for clipboard is especially poor UX (blocks main thread)
- This is a significant UX gap for production readiness

Verdict: FAIL (No toast notification system exists. Success feedback uses inline messages that don't auto-dismiss. Error feedback is inline only. Some actions have no feedback at all. alert() is used for clipboard copy which is poor UX. All test steps fail - toasts are completely unimplemented.)
================================================================================

================================================================================
Test: PERF-003 - Images are optimized and lazy-loaded
Date: 2026-01-05T14:00:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/next.config.js - Next.js image configuration with remotePatterns
- apps/web/src/components/features/landing/HeroImage.tsx - Hero image with Next.js Image, priority, blur placeholder
- apps/web/src/components/features/landing/Testimonials.tsx - Avatar images with Next.js Image, fixed dimensions
- apps/web/src/components/features/recipe/RecipeCard.tsx - Recipe images with fill, onError fallback
- apps/web/src/components/features/recipe/RecipeDetailModal.tsx - Recipe detail image with fill

Test Step Analysis:

1. "Inspect network requests for images" - ✅ Next.js Image optimization active
   - Next.js Image component used consistently across all image locations
   - Image requests would go through /_next/image?url=...&w=...&q=... endpoint
   - Automatic optimization handled by Next.js image optimization pipeline

2. "Verify images use Next.js Image optimization" - ✅ IMPLEMENTED
   
   All image components use next/image:
   - HeroImage.tsx:3 - import Image from 'next/image';
   - Testimonials.tsx:1 - import Image from 'next/image';
   - RecipeCard.tsx:4 - import Image from 'next/image';
   - RecipeDetailModal.tsx:3 - import Image from 'next/image';
   
   Image configuration (next.config.js:13-24):
   - remotePatterns: images.unsplash.com, images.pexels.com allowed
   - Default optimization applies: WebP/AVIF format, quality, sizing

3. "Verify images below fold are lazy-loaded" - ✅/⚠️ PARTIAL
   
   Lazy loading status by component:
   
   HeroImage.tsx:29 - priority={true}
   - CORRECT: Hero image is above fold, should NOT be lazy-loaded
   - Using priority for LCP (Largest Contentful Paint) optimization
   
   Testimonials.tsx:98-104 - No loading prop specified
   - CORRECT: Next.js Image defaults to loading="lazy"
   - Testimonials are below fold, will lazy-load automatically
   
   RecipeCard.tsx:137-145 - No loading prop specified
   - CORRECT: Recipe cards are below fold, will lazy-load automatically
   - fill prop used with parent sizing
   
   RecipeDetailModal.tsx:181-186 - No loading prop specified
   - CORRECT: Modal images lazy-load (modal not visible on initial load)
   
   NOTE: Next.js Image component defaults to loading="lazy" when priority is not set

4. "Check image formats (WebP/AVIF preferred)" - ✅ IMPLEMENTED BY NEXT.JS
   - Next.js automatically serves WebP/AVIF when browser supports it
   - Accept header negotiation done server-side
   - No explicit format configuration needed (default behavior)
   - Images served via /_next/image with content negotiation

5. "Verify appropriate image sizes for viewport" - ⚠️ PARTIAL
   
   Sizes attribute analysis:
   
   HeroImage.tsx:27 - sizes="100vw"
   - CORRECT: Full-width hero needs 100vw
   - Prevents downloading larger images than needed
   
   Testimonials.tsx:99-103 - width={48} height={48}
   - CORRECT: Fixed 48x48 avatar size
   - Small images don't need sizes attribute
   - Could use sizes="48px" for clarity but not required
   
   RecipeCard.tsx:137-145 - fill prop, NO sizes attribute
   - ⚠️ ISSUE: Missing sizes attribute for fill images
   - Without sizes, browser may download larger images than needed
   - Parent container: sm:h-40 sm:w-40 (160px on desktop)
   - RECOMMENDATION: Add sizes="(min-width: 640px) 160px, 100vw"
   
   RecipeDetailModal.tsx:181-186 - fill prop, NO sizes attribute
   - ⚠️ ISSUE: Missing sizes attribute
   - Modal hero image is full-width of modal (max-w-4xl = 896px)
   - RECOMMENDATION: Add sizes="(min-width: 896px) 896px, 100vw"

Image Error Handling:
- HeroImage.tsx:16-20 - Fallback to Unsplash if local image fails
- RecipeCard.tsx:84,142-144 - Fallback to placeholder on error
- RecipeDetailModal.tsx:182 - Falls back to RECIPE_PLACEHOLDER_IMAGE

Blur Placeholders:
- HeroImage.tsx:30-31 - placeholder="blur" with base64 blurDataURL
  * GOOD: Provides visual placeholder while loading
  * Avoids layout shift
- Other images: No blur placeholder
  * OK for small images (avatars) and fill images with parent sizing

Code Issues Found:

1. ISSUE: Missing sizes attribute on fill images
   - RecipeCard.tsx Image lacks sizes prop
   - RecipeDetailModal.tsx Image lacks sizes prop
   - This may cause browser to download larger images than necessary
   - Performance impact: Potentially downloading 2-3x more bytes than needed
   
   FIX for RecipeCard.tsx:137:
   Add: sizes="(min-width: 640px) 160px, 100vw"
   
   FIX for RecipeDetailModal.tsx:181:
   Add: sizes="(min-width: 896px) 896px, 100vw"

2. MINOR: Testimonials avatars could use blur placeholder
   - Currently no placeholder, may show gray box briefly
   - Low impact (small 48x48 images load quickly)

3. MINOR: No explicit AVIF prioritization
   - Next.js defaults to WebP first, then original
   - Could enable AVIF in next.config.js for better compression
   - Configuration: images: { formats: ['image/avif', 'image/webp'] }

4. NOTE: External images (Unsplash, Pexels) are optimized
   - remotePatterns configured correctly in next.config.js
   - Next.js proxy caches and optimizes these images

Positive Observations:
✅ All images use Next.js Image component (no raw <img> tags)
✅ Hero image correctly uses priority for above-fold LCP
✅ Below-fold images use default lazy loading
✅ Hero has blur placeholder preventing layout shift
✅ Error handling with fallbacks prevents broken images
✅ Remote image optimization configured for Unsplash/Pexels
✅ Fill images use parent container sizing correctly

Performance Impact Assessment:
- Hero image: OPTIMIZED (priority, blur, sizes)
- Testimonials: OPTIMIZED (lazy, fixed dimensions)
- Recipe cards: NEEDS IMPROVEMENT (missing sizes)
- Recipe modal: NEEDS IMPROVEMENT (missing sizes)

The missing sizes attributes are the main issue. Without them:
- Browser assumes fill images need full viewport width
- Downloads larger responsive image than container needs
- Example: 160px container may download 1920px image

Verdict: FAIL (Images use Next.js Image component correctly with proper lazy-loading for below-fold content and priority for above-fold hero. However, fill images in RecipeCard and RecipeDetailModal are missing the required sizes attribute, which causes browsers to download larger images than necessary. This is a performance optimization gap that should be fixed before production.)
================================================================================

================================================================================
Test: A11Y-001 - Keyboard navigation works throughout app
Date: 2026-01-05T17:22:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/ui/button.tsx - Uses focus-visible ring, proper button element
- apps/web/src/components/ui/dialog.tsx - Radix Dialog with proper focus management
- apps/web/src/components/ui/checkbox.tsx - Radix Checkbox with focus-visible ring
- apps/web/src/components/ui/select.tsx - Radix Select with focus states
- apps/web/src/components/ui/input.tsx - Native input with focus-visible ring
- apps/web/src/components/ui/sheet.tsx - Vaul drawer with focus management
- apps/web/src/components/ui/accordion.tsx - Radix Accordion (keyboard accessible)
- apps/web/src/components/layout/Header.tsx - Links and buttons with focus-visible outlines
- apps/web/src/components/features/recipe/RecipeCard.tsx - Button wrapper with focus/blur handlers
- apps/web/src/components/features/recipe/RecipeDetailModal.tsx - Dialog with proper structure
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Modal with ESC handling
- apps/web/src/components/features/landing/Hero.tsx - Link buttons properly implemented
- apps/web/src/components/features/landing/Pricing.tsx - Buttons and links accessible
- apps/web/src/components/features/shopping/ShoppingList.tsx - Accordion + button items

Keyboard Accessibility Analysis:

1. "Navigate entire app using only keyboard" - ✅ GENERALLY GOOD
   
   UI Components (shadcn/ui + Radix):
   - All use native HTML elements or Radix primitives
   - Buttons use <button> element with proper type
   - Links use Next.js <Link> component (renders as <a>)
   - Form controls are native HTML elements or Radix
   - Radix components (Dialog, Select, Checkbox, Accordion) have built-in keyboard support

2. "Verify all interactive elements are focusable" - ✅ PASS
   
   All interactive elements use:
   - Native <button>, <a>, <input>, <select> elements
   - Radix primitives that ensure focusability
   - No tabindex="-1" removing elements from tab order
   - No non-focusable divs with onClick handlers (except decorative overlays)

3. "Verify focus order is logical" - ✅ PASS
   
   Tab order follows DOM order which matches visual order:
   - Header: Logo -> Nav links -> Sign out button
   - Forms: Labels flow naturally to inputs
   - Modals: Focus trapped inside modal (Radix/Vaul handles this)
   - Shopping list: Accordion -> buttons -> items (logical flow)
   - No manual tabindex manipulation breaking natural flow

4. "Verify focus indicators are visible" - ✅ PASS (WELL IMPLEMENTED)
   
   Focus indicator implementation analysis:
   
   Button (button.tsx:8):
   - focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2
   - Uses focus-visible (not focus) - only shows for keyboard users
   
   Input (input.tsx:11):
   - focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500 focus-visible:border-emerald-500
   - Clear emerald ring on focus
   
   Select (select.tsx:22):
   - focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500
   - Visible ring on all focus (good for select elements)
   
   Checkbox (checkbox.tsx:16):
   - focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500 focus-visible:ring-offset-2
   - Emerald ring visible on keyboard focus
   
   Dialog close button (dialog.tsx:53):
   - focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2
   - Visible ring on close button
   
   Sheet close button (sheet.tsx:56):
   - focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2
   
   Header links (Header.tsx:15,69):
   - focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-600
   - Clear emerald outline
   
   MealPlanWizard buttons/inputs:
   - All form elements have focus:ring-2 focus:ring-emerald-600
   - Cancel button: focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-600
   - Submit button: focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-600
   
   ShoppingList items (ShoppingList.tsx:248):
   - focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-600
   
   AccordionTrigger (accordion.tsx:30-31):
   - Uses default Radix styling (inherits focus)
   - ⚠️ MINOR ISSUE: No explicit focus-visible ring added
   - Should add: focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500

5. "Verify no keyboard traps" - ✅ PASS
   
   Modal/Dialog handling:
   - Dialog (dialog.tsx): Uses Radix DialogPrimitive which auto-manages focus trap
   - Sheet (sheet.tsx): Uses Vaul Drawer which manages focus
   - MealPlanWizard: Handles ESC key (line 97-106), proper close button
   - All modals can be closed via:
     * ESC key
     * Close button (focusable)
     * Clicking overlay (mouse/touch)
   
   No infinite focus loops detected.

Code Issues Found:

1. MINOR: AccordionTrigger missing explicit focus-visible styling
   - File: apps/web/src/components/ui/accordion.tsx:28-38
   - The trigger has hover:underline but no explicit focus-visible ring
   - Radix provides basic focus handling but visible ring should be added
   - FIX: Add focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500 focus-visible:ring-offset-2

2. MINOR: MealPlanWizard native checkboxes (allergens) hidden with sr-only
   - File: apps/web/src/components/features/meal-plan/MealPlanWizard.tsx:670-675
   - Allergen checkboxes use sr-only class, parent label handles visual
   - This is CORRECT pattern (label is focusable, checkbox is hidden)
   - However, the label itself could benefit from focus-visible styling
   - Currently relies on browser default focus for labels

3. OBSERVATION: Confirmation dialog in MealPlanWizard
   - File: apps/web/src/components/features/meal-plan/MealPlanWizard.tsx:704-738
   - Uses custom modal implementation (not Radix Dialog)
   - Has proper role="alertdialog" and aria-labelledby/describedby
   - Buttons have focus-visible styling
   - ⚠️ MINOR: No focus trap implementation
   - When dialog opens, focus should move to first button
   - User could tab outside dialog to background elements
   - LOW PRIORITY: Dialog is small and temporary

Positive Observations:
✅ Consistent use of focus-visible (not just focus) across components
✅ Ring styles use consistent emerald-500/600 color scheme
✅ All buttons use proper <button> elements with type attribute
✅ Links use Next.js <Link> component for proper accessibility
✅ Radix UI components provide excellent keyboard support out of box
✅ Custom interactive elements (RecipeCard, ShoppingList items) use button wrappers
✅ ESC key handling for modals/wizards
✅ aria-label on icon-only buttons (Header.tsx:93, RecipeCard.tsx:132)
✅ sr-only text for close buttons in dialogs/sheets
✅ aria-pressed on toggle buttons (ShoppingList.tsx:252)
✅ aria-expanded on collapsible sections (MealPlanWizard.tsx:539)

Skip Link Analysis:
- ⚠️ OBSERVATION: No skip navigation link present
- For production, consider adding skip-to-content link at start of page
- This is a WCAG 2.4.1 recommendation for keyboard users
- Not a blocker but would improve keyboard navigation efficiency

Browser/Platform Compatibility:
- focus-visible is well-supported (94%+ browser support)
- ring-offset uses CSS outline which is universally supported
- No browser-specific keyboard issues expected

Summary:
The application has GOOD keyboard accessibility overall. The use of Radix UI 
primitives and consistent focus-visible styling means keyboard users can 
navigate the entire app effectively. All interactive elements are focusable,
focus order is logical, and focus indicators are clearly visible with 
consistent emerald ring styling.

Minor issues found:
1. AccordionTrigger could use more visible focus ring
2. Confirmation dialog in MealPlanWizard lacks focus trap
3. No skip-to-content link for efficiency

None of these are blocking issues - the app is usable via keyboard.

Verdict: PASS (Minor improvements recommended but keyboard navigation works throughout the app)
================================================================================

================================================================================
Test: A11Y-002 - Screen reader announces content correctly
Date: 2026-01-05T18:45:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/components/layout/Header.tsx - Navigation with mobile menu
- apps/web/src/components/features/landing/Hero.tsx - Hero section
- apps/web/src/components/features/landing/HeroImage.tsx - Background image
- apps/web/src/components/features/landing/FeatureCards.tsx - Feature cards
- apps/web/src/components/features/landing/Pricing.tsx - Pricing section
- apps/web/src/components/features/landing/Testimonials.tsx - Testimonials
- apps/web/src/components/features/recipe/RecipeCard.tsx - Recipe cards
- apps/web/src/components/features/recipe/RecipeDetailModal.tsx - Recipe modal
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Wizard form
- apps/web/src/components/features/shopping/ShoppingList.tsx - Shopping list
- apps/web/src/components/ui/dialog.tsx - Dialog component
- apps/web/src/app/auth/signin/page.tsx - Sign in form
- apps/web/src/app/auth/_components/PasswordInput.tsx - Password input

Test Steps Analysis:

1. "Verify images have alt text" - MOSTLY PASS with ISSUES

   ✅ HeroImage.tsx:25 - alt="Fresh ingredients for home cooking in an Irish kitchen"
   ✅ Testimonials.tsx:100 - alt={`${testimonial.author} avatar`} (dynamic)
   ✅ RecipeCard.tsx:139 - alt={recipe.title} (dynamic)
   ✅ RecipeDetailModal.tsx:183 - alt={recipe.title} (dynamic)
   
   ⚠️ ISSUE: RecipeCard.tsx:139 - alt={recipe.title} is just the recipe name
      - Should be more descriptive: "Photo of {recipe.title}"
      - Not a blocker but could be improved
   
   Decorative images properly hidden:
   ✅ Hero.tsx:13 - aria-hidden="true" on gradient overlay
   ✅ Pricing.tsx:95-100 - aria-hidden="true" on decorative blur circles
   ✅ MealPlanWizard.tsx:257,273,289 - aria-hidden="true" on visual icons
   ✅ Testimonials.tsx:79 - aria-hidden="true" on gradient background

2. "Verify form labels are associated" - PASS

   All forms use proper htmlFor/id associations:
   
   SignIn page (signin/page.tsx):
   ✅ Line 115-127: <label htmlFor="email"> properly associated with <input id="email">
   ✅ Line 133-153: <label htmlFor="password"> associated with PasswordInput id="password"
   
   MealPlanWizard.tsx:
   ✅ Line 335-368: <label htmlFor="householdSize"> with <select id="householdSize">
   ✅ Line 373-405: <label htmlFor="mealsPerDay"> with <select id="mealsPerDay">  
   ✅ Line 409-451: <label htmlFor="days"> with <select id="days">
   ✅ Line 465-502: <label htmlFor="isVegetarian"/"isDairyFree"> with checkboxes
   ✅ Line 507-531: <label htmlFor="dislikes"> with <input id="dislikes">
   ✅ Line 570-606: <label htmlFor="difficulty"> with <select id="difficulty">
   ✅ Line 609-643: <label htmlFor="maxTotalTime"> with <select id="maxTotalTime">
   
   ⚠️ ISSUE: Allergen checkboxes (MealPlanWizard.tsx:661-679)
      - The label wraps the checkbox but checkboxes are sr-only
      - Labels don't have htmlFor attribute
      - HOWEVER, this is acceptable because the <label> wrapping pattern works
      - Screen readers WILL announce: "label text, checkbox, not checked"

3. "Verify heading hierarchy is correct" - FAIL (ISSUES FOUND)

   Landing Page (app/page.tsx):
   ✅ Hero.tsx:19 - <h1> "Your Family, Fed and Happy"
   ✅ FeatureCards.tsx:59 - <h2> section heading
   ✅ FeatureCards.tsx:87 - <h3> for each feature card
   ✅ Pricing.tsx:35 - <h2> section heading
   ✅ Pricing.tsx:103 - <h3> tier name
   ✅ Testimonials.tsx:60 - <h2> section heading
   
   ShoppingList.tsx:
   ✅ Line 182: <h2> "Shopping List"
   ✅ Line 205: <h3> for each category accordion
   
   RecipeDetailModal.tsx:
   ✅ Line 202: DialogTitle (renders as h2 via Radix)
   ✅ Line 276: <h3> "Ingredients"
   ✅ Line 299: <h3> "Instructions"
   
   MealPlanWizard.tsx:
   ✅ Line 240: <h2 id="wizard-title">
   
   ⚠️ ISSUE: RecipeCard.tsx:180 uses <h4> for recipe title
      - In context of a meal plan page, this may skip heading levels
      - If parent page has h1 > h2, recipe cards should be h3
      - This is a contextual issue depending on parent page structure
   
   ⚠️ ISSUE: Dashboard and plan pages not analyzed in detail
      - Would need to verify h1 exists on each page
      - Would need to check no levels are skipped

4. "Verify ARIA labels on icon buttons" - PASS

   ✅ Header.tsx:93 - aria-label="Toggle menu" on mobile menu button
   ✅ RecipeCard.tsx:132 - aria-label={`View details for ${recipe.title}`}
   ✅ ShoppingList.tsx:251 - aria-label={`Toggle ${item.name}`}
   ✅ ShoppingList.tsx:252 - aria-pressed={isChecked} (toggle state)
   ✅ PasswordInput.tsx:48 - aria-label={showPassword ? 'Hide password' : 'Show password'}
   ✅ Dialog.tsx:55 - <span className="sr-only">Close</span>
   ✅ MealPlanWizard.tsx:198 - aria-label="Cancel and return to dashboard"
   
   Icon decorative attributes:
   ✅ FeatureCards.tsx:85 - aria-hidden="true" on feature icons
   ✅ MealPlanWizard.tsx:366,402,443,601,639 - aria-hidden="true" on chevron icons
   ✅ SignIn.tsx:103,174,224 - aria-hidden="true" on SVG icons

5. "Additional ARIA attributes" - MOSTLY PASS

   Live regions:
   ✅ SignIn.tsx:92-93 - role="alert" aria-live="polite" on error message
   
   Modal/Dialog:
   ✅ MealPlanWizard.tsx:164-166 - role="dialog" aria-modal="true" aria-labelledby="wizard-title"
   ✅ MealPlanWizard.tsx:711-713 - role="alertdialog" aria-labelledby/describedby on confirm
   ✅ Dialog.tsx - Uses Radix DialogPrimitive which handles ARIA
   ✅ RecipeDetailModal.tsx:177 - Uses Dialog which uses Radix
   
   Expanded state:
   ✅ MealPlanWizard.tsx:539 - aria-expanded={showAdvancedFilters}
   
   Busy state:
   ✅ SignIn.tsx:163 - aria-busy={loading}
   
   Sheet/Mobile menu:
   ✅ Header.tsx:100 - <SheetTitle className="sr-only">Navigation menu</SheetTitle>

Code Issues Found:

1. MINOR: RecipeCard heading level may be incorrect
   - File: apps/web/src/components/features/recipe/RecipeCard.tsx:180
   - Uses <h4> but context determines if this is appropriate
   - Should verify parent page has h1 > h2 > h3 structure

2. MINOR: Recipe image alt text could be more descriptive
   - File: apps/web/src/components/features/recipe/RecipeCard.tsx:139
   - alt={recipe.title} - just "Spaghetti Carbonara"
   - Better: "Photo of Spaghetti Carbonara" or role="img" with longer aria-label

3. OBSERVATION: No skip navigation link
   - No "Skip to main content" link at start of page
   - Noted in A11Y-001 as well
   - WCAG 2.4.1 recommendation for screen reader users

4. OBSERVATION: Emoji role attributes inconsistently applied
   - MealPlanWizard.tsx uses role="img" aria-label on some emojis (lines 341-346)
   - Other emojis just use aria-hidden="true"
   - This is ACCEPTABLE - informational emojis get role/aria-label, decorative ones get aria-hidden

5. MEDIUM: Stars in Testimonials don't announce rating count
   - File: apps/web/src/components/features/landing/Testimonials.tsx:83-89
   - Stars are aria-hidden="true" (correct)
   - BUT no accessible text announces "5 out of 5 stars"
   - Screen reader users won't know the rating
   - FIX: Add <span className="sr-only">{rating} out of 5 stars</span>

6. MINOR: Testimonial figure aria-label is redundant
   - File: apps/web/src/components/features/landing/Testimonials.tsx:76-77
   - <figure aria-label={`Testimonial from ${author} in ${location}`}>
   - The figcaption already provides this info
   - Not harmful but slightly redundant

Positive Observations:
✅ Consistent use of aria-hidden on decorative elements
✅ All icon-only buttons have aria-label or sr-only text
✅ Form inputs properly associated with labels
✅ Error messages use role="alert" aria-live="polite"
✅ Modal dialogs use correct ARIA patterns (Radix handles this well)
✅ Toggle buttons correctly use aria-pressed
✅ Loading states correctly use aria-busy
✅ Mobile menu has sr-only title for screen readers
✅ Emojis with meaning have role="img" and aria-label
✅ Decorative emojis/icons have aria-hidden="true"

Recommendations for Production:
1. Add accessible rating text to testimonials stars
2. Consider more descriptive alt text for recipe images
3. Verify heading hierarchy on all pages (h1 > h2 > h3 without skips)
4. Add skip-to-content link for keyboard/screen reader efficiency

Verdict: FAIL (Critical issue: Star ratings in testimonials are completely invisible to screen readers. The rating value (5 stars) has no accessible text - stars use aria-hidden but no sr-only text announces the actual rating number. This means blind users cannot perceive testimonial ratings at all. Additionally, recipe card heading levels may cause hierarchy violations depending on page context. Core form accessibility is good.)
================================================================================

================================================================================
Test: A11Y-003 - Color contrast meets WCAG AA standards
Date: 2026-01-05T19:00:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/styles/globals.css - CSS variables with OKLCH color definitions
- apps/web/src/components/ui/button.tsx - Button color variants
- apps/web/src/components/ui/input.tsx - Input styling including placeholder
- apps/web/src/components/ui/badge.tsx - Badge color variants
- apps/web/src/components/features/landing/Hero.tsx - Hero section colors
- apps/web/src/components/features/landing/Pricing.tsx - Pricing section colors
- apps/web/src/components/features/landing/FeatureCards.tsx - Feature cards
- apps/web/src/components/layout/Header.tsx - Navigation colors
- apps/web/src/components/features/shopping/ShoppingList.tsx - Shopping list
- apps/web/src/components/features/recipe/RecipeCard.tsx - Recipe card colors
- apps/web/src/app/auth/signin/page.tsx - Auth form colors

Test Steps Analysis:

1. "Verify text contrast ratio >= 4.5:1" - MOSTLY PASS with ISSUES

   PASS - Primary text combinations:
   ✅ text-gray-900 on bg-white - Black/near-black on white: ~15:1 ratio
   ✅ text-white on bg-emerald-600 - White on emerald: ~4.5:1 ratio
   ✅ text-gray-700 on bg-white - Dark gray on white: ~8:1 ratio
   ✅ text-gray-900 on bg-gray-50 - Near-black on light gray: ~12:1 ratio
   ✅ text-emerald-900 on bg-emerald-50 - Dark emerald on light emerald: ~7:1
   
   POTENTIAL ISSUES - Lower contrast combinations:
   
   ⚠️ ISSUE: text-gray-600 on bg-white
      - File: Multiple (Pricing.tsx:38, FeatureCards.tsx:62, etc.)
      - Gray-600 (#4B5563) on white: ~5.9:1 - PASSES AA but borderline
      - Commonly used for secondary/descriptive text
      - VERDICT: PASS (meets 4.5:1 minimum)
   
   ⚠️ ISSUE: placeholder:text-gray-600 on white input
      - File: apps/web/src/app/auth/signin/page.tsx:124
      - Gray-600 placeholder on white input: ~5.9:1
      - VERDICT: PASS (but gray-400 in input.tsx is problematic)
   
   ❌ ISSUE: placeholder:text-gray-400 in Input component
      - File: apps/web/src/components/ui/input.tsx:11
      - Gray-400 (#9CA3AF) on white: ~2.9:1 - FAILS AA (needs 4.5:1)
      - This is a common accessibility problem with placeholders
      - FIX: Change to placeholder:text-gray-500 (~4.6:1) or darker
   
   ⚠️ ISSUE: text-gray-400 for time breakdown in RecipeCard
      - File: apps/web/src/components/features/recipe/RecipeCard.tsx:198
      - "text-xs text-gray-400" for prep/cook breakdown
      - Gray-400 on gray-50/white: ~2.9:1 - FAILS AA
      - FIX: Change to text-gray-500 or text-gray-600
   
   ✅ text-emerald-700 on bg-emerald-100: ~4.8:1 - PASSES
   ✅ text-amber-700 on bg-amber-100: ~4.6:1 - PASSES
   ✅ text-blue-700 on bg-blue-100: ~4.7:1 - PASSES
   ✅ text-purple-700 on bg-purple-100: ~4.8:1 - PASSES
   ✅ text-red-700 on bg-red-100: ~5.1:1 - PASSES

2. "Verify large text contrast >= 3:1" - PASS

   Large text (18pt+/14pt bold+) has more lenient requirements:
   ✅ Hero h1: text-white on emerald gradient - ~4.5:1 (exceeds 3:1)
   ✅ Section headings: text-gray-900 on white/gray - ~15:1
   ✅ Pricing tier names: text-gray-900 on white card - ~15:1
   ✅ All large text easily exceeds 3:1 requirement

3. "Check error states have sufficient contrast" - PASS

   Error/alert styling reviewed:
   ✅ SignIn error: border-amber-200 bg-amber-50, text-amber-900
      - Amber-900 on amber-50: ~8.5:1 - PASSES
      - Icon: text-amber-700 on amber-50: ~4.6:1 - PASSES
   
   ✅ Destructive button: bg-destructive text-white
      - Using oklch(0.577 0.245 27.325) which is red-ish
      - White on this red: ~4.5:1 - PASSES

4. "Verify links are distinguishable from text" - MOSTLY PASS

   Link styling reviewed:
   ✅ text-emerald-600 links on white background
      - Emerald-600 on white: ~4.5:1 - PASSES
      - Has hover state (text-emerald-500) which may be slightly lower
   
   ⚠️ ISSUE: Links rely primarily on color alone
      - File: apps/web/src/app/auth/signin/page.tsx:80-83
      - "Create an account" link uses color only (no underline by default)
      - Link variant button (button.tsx:19) has underline-offset-4 hover:underline
      - Some links are distinguishable by context but not visually marked
      - WCAG recommends non-color indicator (underline) for inline links
      - VERDICT: Acceptable but could be improved with underlines

5. Badge contrast analysis - MOSTLY PASS with ISSUES

   ✅ default: bg-emerald-100 text-emerald-700 - ~4.8:1 PASSES
   ✅ mealType: bg-emerald-600 text-white - ~4.5:1 PASSES
   ✅ easy: bg-green-100 text-green-700 - ~4.7:1 PASSES
   ✅ medium: bg-amber-100 text-amber-700 - ~4.6:1 PASSES
   ✅ hard: bg-red-100 text-red-700 - ~5.1:1 PASSES
   ✅ premium: bg-amber-100 text-amber-700 - ~4.6:1 PASSES
   
   ⚠️ ISSUE: Lighter variant backgrounds may be borderline
   - vegetarian: bg-green-50 text-green-700 - ~4.1:1 - BORDERLINE (fails 4.5:1)
   - vegan: bg-emerald-50 text-emerald-700 - ~4.2:1 - BORDERLINE (fails 4.5:1)
   - dairyFree: bg-blue-50 text-blue-700 - ~4.1:1 - BORDERLINE (fails 4.5:1)
   - glutenFree: bg-purple-50 text-purple-700 - ~4.0:1 - BORDERLINE (fails 4.5:1)
   
   FIX: Change -50 backgrounds to -100 for these variants

6. Disabled state contrast - ISSUE

   ⚠️ ISSUE: disabled:opacity-50 reduces contrast
   - File: apps/web/src/components/ui/button.tsx:8
   - Disabled buttons use opacity-50 which may drop below AA
   - Emerald-600 at 50% opacity on white: ~2.3:1 - FAILS
   - Common pattern but technically violates WCAG AA for disabled controls
   - WCAG does not require disabled controls to meet contrast, but it's best practice
   - OBSERVATION: Not a blocker, but could use bg-emerald-300 instead

7. Focus indicator contrast - PASS

   Focus rings are visible:
   ✅ focus-visible:ring-emerald-500 - Emerald ring is clearly visible
   ✅ focus-visible:ring-2 ring-offset-2 - Clear 2px ring with offset
   ✅ Consistent focus styling across components

8. Dark mode contrast - NOT TESTED (dark mode not actively used)

   The app has dark mode CSS variables defined but UI doesn't appear to 
   implement a dark mode toggle. Variables look reasonable:
   - --foreground: oklch(0.985 0 0) - Near white
   - --background: oklch(0.145 0 0) - Near black
   - --muted-foreground: oklch(0.708 0 0) - Should be verified

Code Issues Found:

1. CRITICAL: Input placeholder color too light
   - File: apps/web/src/components/ui/input.tsx:11
   - placeholder:text-gray-400 fails WCAG AA (2.9:1 vs 4.5:1 required)
   - FIX: Change to placeholder:text-gray-500

2. MEDIUM: Recipe card time breakdown too light
   - File: apps/web/src/components/features/recipe/RecipeCard.tsx:198
   - text-gray-400 fails WCAG AA
   - FIX: Change to text-gray-500 or text-gray-600

3. MEDIUM: Badge variants using -50 backgrounds may fail
   - File: apps/web/src/components/ui/badge.tsx:23-26
   - vegetarian, vegan, dairyFree, glutenFree use bg-X-50
   - These are borderline ~4.0-4.2:1 (AA requires 4.5:1)
   - FIX: Use -100 backgrounds instead of -50

4. MINOR: Inline links lack non-color distinguisher
   - Multiple files
   - Text links use color alone without underline
   - RECOMMENDATION: Add underline to inline links

5. OBSERVATION: Disabled button opacity approach
   - opacity-50 technically fails but WCAG exempts disabled controls
   - Could be improved for better usability

Positive Observations:
✅ Primary text colors (gray-900, gray-700) have excellent contrast
✅ Button default variant (emerald-600 + white) meets AA
✅ Error states use accessible amber color scheme
✅ Focus indicators are clearly visible with ring styling
✅ Large text (headings) easily exceeds contrast requirements
✅ Most badge variants properly use -700 text on -100 backgrounds
✅ Consistent use of gray-900 for headings and important text

WCAG AA Summary:
- Text >= 4.5:1: MOSTLY PASS (2-3 failures in gray-400 usage)
- Large text >= 3:1: PASS
- Error states: PASS
- Links distinguishable: PASS (color) / BORDERLINE (non-color)

Recommendations for Production:
1. Fix input placeholder: text-gray-400 → text-gray-500
2. Fix RecipeCard time: text-gray-400 → text-gray-500
3. Fix badge -50 backgrounds → -100 for diet tags
4. Consider adding underlines to inline links
5. Audit dark mode if implemented

Verdict: FAIL (Multiple text-gray-400 usages fail the 4.5:1 contrast requirement. The input placeholder at 2.9:1 is a clear accessibility violation. Badge diet variants using -50 backgrounds are borderline. Core content is accessible but these specific issues need fixing for WCAG AA compliance.)
================================================================================

================================================================================
Test: SEC-001 - Authentication tokens are secure
Date: 2026-01-05T19:30:00+00:00
Status: PASS
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/auth/config.ts - NextAuth configuration with JWT sessions
- apps/web/src/server/auth/index.ts - Auth exports with caching
- apps/web/src/app/api/auth/[...nextauth]/route.ts - NextAuth API route handlers
- apps/web/src/server/api/routers/passwordReset.ts - Password reset token handling

Security Analysis:

1. HttpOnly flag - PASS ✅
   - File: apps/web/src/server/auth/config.ts:162
   - Cookie options explicitly set: `httpOnly: true`
   - This prevents JavaScript access to session cookies, mitigating XSS attacks

2. Secure flag - PASS ✅
   - File: apps/web/src/server/auth/config.ts:166
   - Cookie options set: `secure: process.env.NODE_ENV === 'production'`
   - In production, cookies will only be sent over HTTPS
   - In development, allows non-HTTPS for localhost testing (acceptable)

3. SameSite attribute - PASS ✅
   - File: apps/web/src/server/auth/config.ts:163
   - Cookie options set: `sameSite: 'lax'`
   - Provides CSRF protection while allowing normal navigation
   - 'lax' is appropriate for this use case (allows top-level navigation)

4. Token expiration - PASS (uses NextAuth defaults) ✅
   - No explicit maxAge set in config
   - NextAuth v5 JWT default: 30 days (reasonable)
   - Session strategy is JWT (line 152): `strategy: 'jwt'`
   - JWT tokens are signed with AUTH_SECRET (line 94)

5. Cookie naming security - PASS ✅
   - File: apps/web/src/server/auth/config.ts:157-159
   - Production uses `__Secure-` prefix: `__Secure-next-auth.session-token`
   - `__Secure-` prefix enforces that cookie must be set with Secure flag
   - Development uses standard name for easier debugging

6. AUTH_SECRET configuration - PASS ✅
   - File: apps/web/src/server/auth/config.ts:94
   - Uses `env.AUTH_SECRET` from environment
   - Required for signing JWTs - if missing, app would fail to start

7. Password hashing security - PASS ✅
   - File: apps/web/src/server/auth/config.ts:119-124
   - Uses Argon2 with proper parameters:
     - memoryCost: 19456 (19MB)
     - timeCost: 2 iterations
     - outputLen: 32 bytes
     - parallelism: 1
   - These are OWASP-compliant Argon2id parameters

8. Password reset token security - PASS ✅
   - File: apps/web/src/server/api/routers/passwordReset.ts:10
   - Token expiry: 1 hour (appropriate)
   - Uses cryptographically secure random tokens (32 bytes)
   - Tokens are single-use (marked used after reset)
   - Rate limiting: 3 requests per hour per email
   - No user enumeration (same response for existing/non-existing users)

9. Trust Host configuration - OBSERVATION
   - File: apps/web/src/server/auth/config.ts:36,66,154
   - `AUTH_TRUST_HOST` set to 'true' and `trustHost: true`
   - This is required for deployments behind reverse proxies (Cloud Run, etc.)
   - Not a security issue when properly configured infrastructure

Observations:
- Cookie security configuration follows industry best practices
- JWT session strategy with proper signing
- Strong password hashing with Argon2
- No obvious security vulnerabilities in session handling
- Production cookie name uses __Secure- prefix for additional protection
- Path is properly set (defaults to '/' or uses BASE_PATH)

Positive Security Features:
✅ HttpOnly cookies prevent XSS session theft
✅ Secure flag in production ensures HTTPS-only transmission
✅ SameSite=lax provides CSRF protection
✅ __Secure- cookie prefix in production
✅ Strong Argon2 password hashing
✅ Cryptographically secure password reset tokens
✅ Rate limiting on password reset
✅ No credential enumeration on password reset

Verdict: PASS - All authentication token security requirements are met. The implementation follows OWASP security guidelines and NextAuth best practices.
================================================================================

================================================================================
Test: SEC-002 - API endpoints validate authentication
Date: 2026-01-05T20:00:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/api/trpc.ts - tRPC middleware with publicProcedure, protectedProcedure, premiumProcedure, adminProcedure
- apps/web/src/server/api/routers/plan.ts - Meal plan endpoints (all use protectedProcedure)
- apps/web/src/server/api/routers/shoppingList.ts - Shopping list endpoints (all use protectedProcedure)
- apps/web/src/server/api/routers/preferences.ts - User preferences endpoints (all use protectedProcedure)
- apps/web/src/server/api/routers/mealPlan.ts - Alternate meal plan router (all use protectedProcedure)
- apps/web/src/server/api/routers/adminImage.ts - Admin image generation (uses adminProcedure)
- apps/web/src/server/api/routers/passwordReset.ts - Password reset (uses publicProcedure - correct)
- apps/web/src/server/api/routers/post.ts - Demo posts (hello is public, rest protected)
- apps/web/src/app/dashboard/admin/images/page.tsx - Admin page with role check

Test Step Analysis:

1. Attempt to access tRPC endpoints without auth: ✅ PROTECTED
   - protectedProcedure (trpc.ts:126-136) checks ctx.session?.user
   - If no session: throws TRPCError({ code: 'UNAUTHORIZED' })
   - This returns HTTP 401 to the client

2. Verify 401/403 responses: ✅ IMPLEMENTED
   - UNAUTHORIZED (401) returned when session missing
   - FORBIDDEN (403) returned for role violations (premium, admin)
   - premiumProcedure (trpc.ts:146-162): Returns FORBIDDEN if not premium
   - adminProcedure (trpc.ts:167-182): Returns FORBIDDEN if not admin

3. Attempt to access other users' meal plans: ✅ PROTECTED WITH OWNERSHIP CHECK
   - plan.getById (plan.ts:150-152): Verifies plan.userId === ctx.session.user.id
   - plan.swapRecipe (plan.ts:246-251): Verifies ownership, throws FORBIDDEN
   - plan.regenerate (plan.ts:410-415): Verifies ownership, throws FORBIDDEN
   - shoppingList.getForPlan (shoppingList.ts:35-37): Verifies plan.userId === session.user.id
   - mealPlan.delete (mealPlan.ts:212-214): Verifies ownership before deletion

4. Verify authorization check prevents access: ✅ IMPLEMENTED
   - All meal plan operations verify userId matches session.user.id
   - Unauthorized access throws Error('Unauthorized') or TRPCError(code: 'FORBIDDEN')

5. Verify admin endpoints require admin role: ✅ PROTECTED
   - adminImage.list: Uses adminProcedure (line 15)
   - adminImage.generate: Uses adminProcedure (line 43)
   - Admin page (dashboard/admin/images/page.tsx:15-17): Server-side role check
     if (session.user.role !== 'admin') { redirect('/dashboard'); }

Procedure Type Summary:

publicProcedure (used for):
- post.hello - Public greeting endpoint
- passwordReset.requestReset - Must be public for unauthenticated users
- passwordReset.verifyToken - Must be public for reset flow
- passwordReset.resetPassword - Must be public for reset flow

protectedProcedure (requires authentication):
- All plan routes: generate, getById, getLast, list, swapRecipe, regenerate
- All mealPlan routes: getCurrent, generate, delete
- All shoppingList routes: getForPlan, getForMealPlan, toggleItemChecked, updateCategoryChecked, exportCSV
- All preferences routes: get, update
- post.create, post.getLatest, post.getSecretMessage

premiumProcedure (requires premium role):
- Currently not used in any router (defined but unused)
- Note: Price comparison is feature-flagged client-side, not API-enforced

adminProcedure (requires admin role):
- adminImage.list
- adminImage.generate

Security Issues Found:

1. ISSUE: shoppingList.toggleItemChecked lacks ownership verification
   - File: shoppingList.ts:193-199 and shoppingListService.toggleItemChecked
   - The mutation accepts an itemId and toggles it without verifying the user owns it
   - A malicious user could toggle items in another user's shopping list by guessing itemIds
   - Flow: toggleItemChecked(itemId) → service.toggleItemChecked(itemId) → No user check
   - FIX NEEDED: Should verify ShoppingList → MealPlan → userId matches session.user.id

2. ISSUE: shoppingList.updateCategoryChecked lacks ownership verification
   - File: shoppingList.ts:202-214
   - Takes shoppingListId and category, updates without user verification
   - A malicious user could bulk-update another user's shopping list items
   - FIX NEEDED: Should verify ShoppingList → MealPlan → userId matches session.user.id

3. MINOR: plan.getById throws generic Error instead of TRPCError
   - File: plan.ts:151-152: throw new Error('Unauthorized')
   - Should use TRPCError({ code: 'FORBIDDEN' }) for consistency
   - Same issue at plan.ts:145-147: throw new Error('Meal plan not found')
   - Should use TRPCError({ code: 'NOT_FOUND' })

4. OBSERVATION: premiumProcedure defined but never used
   - Price comparison feature check is client-side only
   - Premium-exclusive APIs should use premiumProcedure for defense in depth

Ownership Check Patterns:

CORRECT Pattern (plan.swapRecipe):
```javascript
if (plan.userId !== ctx.session.user.id) {
  throw new TRPCError({
    code: 'FORBIDDEN',
    message: 'Unauthorized to modify this meal plan',
  });
}
```

INCORRECT Pattern (shoppingList.toggleItemChecked):
```javascript
async toggleItemChecked(itemId: string): Promise<void> {
  const item = await this.prisma.shoppingListItem.findUnique({...});
  if (!item) throw new Error('Shopping list item not found');
  // ❌ NO USER OWNERSHIP CHECK
  await this.prisma.shoppingListItem.update({...});
}
```

API Tests (if server running):

Test 1: Unauthenticated access to protected endpoint
- Endpoint: POST /api/trpc/plan.generate
- Expected: 401 UNAUTHORIZED
- Result: ✅ Correctly returns UNAUTHORIZED (code review confirms)

Test 2: Cross-user meal plan access
- Endpoint: GET /api/trpc/plan.getById?input={"planId":"<other_user_plan>"}
- Expected: 403 FORBIDDEN or plan not found
- Result: ✅ Returns Error('Unauthorized') (code review confirms)

Test 3: Non-admin access to admin endpoint
- Endpoint: POST /api/trpc/adminImage.generate
- Expected: 403 FORBIDDEN with "Admin privileges required"
- Result: ✅ Correctly returns FORBIDDEN (code review confirms)

Test 4: Toggle shopping list item without ownership
- Endpoint: POST /api/trpc/shoppingList.toggleItemChecked
- Expected: Should verify ownership
- Result: ❌ NO OWNERSHIP CHECK - Security vulnerability

Observations:
- tRPC middleware architecture is correct with proper procedure hierarchy
- Most endpoints correctly implement authentication and authorization
- Two shopping list mutations have missing ownership checks (security vulnerabilities)
- Error handling inconsistent between Error and TRPCError in some places
- Admin endpoints correctly protected at both API and page level
- Password reset correctly uses publicProcedure (required for unauthenticated flow)
- User preferences correctly scoped by userId in all queries

Verdict: FAIL (SECURITY VULNERABILITIES: toggleItemChecked and updateCategoryChecked in shopping list router lack ownership verification, allowing cross-user data modification. Additionally, inconsistent error handling with generic Error vs TRPCError)
================================================================================

================================================================================
Test: SEC-003 - Input validation prevents XSS and injection
Date: 2026-01-05T21:30:00+00:00
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/api/routers/preferences.ts - Zod validation for user preferences
- apps/web/src/server/api/routers/post.ts - Zod validation for posts
- apps/web/src/server/api/routers/plan.ts - Zod validation for meal plan generation
- apps/web/src/server/api/routers/mealPlan.ts - Zod validation for meal plan operations
- apps/web/src/server/api/routers/passwordReset.ts - Zod validation for password reset
- apps/web/src/app/api/auth/signup/schema.ts - Zod schema for signup validation
- apps/web/src/app/api/auth/signup/route.ts - Server-side signup validation
- apps/web/src/app/auth/signup/page.tsx - Frontend signup form
- apps/web/src/app/auth/signin/page.tsx - Frontend signin form
- apps/web/src/server/api/trpc.ts - Error formatter and procedures

Test Step Analysis:

1. XSS payload in form inputs: ✅ PROTECTED
   - React JSX expressions automatically escape user content (e.g., {recipe.title}, {item.name})
   - No dangerouslySetInnerHTML usage found in the codebase
   - No innerHTML direct assignments found
   - No eval() or new Function() with user input found
   - All user-generated content rendered through React's safe JSX interpolation

2. Output escaped/sanitized: ✅ PROTECTED
   - React's default rendering behavior escapes HTML entities
   - User input like `dislikes` field is:
     - Validated on server with Zod (z.string().optional())
     - Passed to database via Prisma (parameterized queries)
     - Rendered in React JSX (auto-escaped)

3. SQL-like payloads in search: ✅ PROTECTED (Prisma ORM)
   - No raw SQL queries found ($executeRaw, $queryRaw only in test mocks)
   - All database operations use Prisma ORM with parameterized queries
   - Example: ctx.db.user.findUnique({ where: { email } })
   - Prisma automatically parameterizes all inputs, preventing SQL injection

4. No SQL errors exposed: ✅ PROTECTED
   - Error handler in trpc.ts only exposes ZodError (validation errors)
   - Internal errors wrapped in TRPCError with generic messages
   - signup/route.ts returns "Internal server error" for exceptions
   - No stack traces or database error details leaked to client

5. Error messages don't leak system info: ✅ MOSTLY PROTECTED
   - API errors return generic messages (e.g., "Internal server error")
   - Zod validation errors are exposed (intended for field-level feedback)
   - No database connection strings, paths, or internal IDs exposed

Input Validation Summary:

All API inputs validated with Zod:
- Email: z.string().email() - Valid email format required
- Password: z.string().min(8).max(128).regex(/[A-Z]/).regex(/[0-9]/)
- Name: z.string().trim().min(1) - Non-empty after trimming
- Days: z.number().min(1).max(7) - Range validation
- HouseholdSize: z.number().min(1).max(10) - Range validation
- MealsPerDay: z.number().min(1).max(3) - Range validation
- Tier: z.enum(['basic', 'premium']) - Whitelist validation
- Difficulty: z.enum(['EASY', 'MEDIUM', 'HARD']).optional() - Whitelist
- PlanId/ItemId: z.string() - UUID format (Prisma enforces)

Security Issues Found:

1. ISSUE: Open Redirect Vulnerability in SignIn Page
   - File: apps/web/src/app/auth/signin/page.tsx:19,37
   - Code: 
     const callbackUrl = searchParams.get('callbackUrl') ?? '/dashboard';
     router.push(callbackUrl);
   - Risk: Attacker can craft URL like /auth/signin?callbackUrl=https://evil.com
   - After login, user is redirected to attacker's phishing site
   - Severity: MEDIUM (requires user interaction, but exploitable for phishing)
   - FIX NEEDED: Validate callbackUrl is relative or on same origin:
     ```
     const isRelativeUrl = (url: string) => url.startsWith('/') && !url.startsWith('//');
     const safeCallbackUrl = isRelativeUrl(callbackUrl) ? callbackUrl : '/dashboard';
     router.push(safeCallbackUrl);
     ```

2. OBSERVATION: Console.error in production
   - Files: signin/page.tsx:44, signup/page.tsx:127
   - console.error('Sign in error:', err) - Logs full error object
   - Not a direct security issue but could log sensitive info in browser console
   - Recommendation: Use structured logging or remove in production

Positive Security Features:
✅ Zod schema validation on all API inputs
✅ Prisma ORM prevents SQL injection (no raw queries)
✅ React JSX escapes output (XSS prevention)
✅ No dangerouslySetInnerHTML usage
✅ No eval() or dynamic code execution with user input
✅ Generic error messages hide internal details
✅ Argon2id password hashing with strong parameters
✅ Rate limiting on password reset

API Tests (if server running):

Test 1: XSS in user name field
- Payload: <script>alert('xss')</script>
- Result: Would be stored as plain text, rendered escaped in React
- Verdict: ✅ SAFE

Test 2: SQL injection in email field
- Payload: ' OR '1'='1
- Result: Zod rejects (not valid email format)
- If it passed: Prisma would parameterize it
- Verdict: ✅ SAFE

Test 3: XSS in dislikes field
- Payload: <img src=x onerror=alert('xss')>
- Result: Stored as plain text, used in server-side filtering only
- Verdict: ✅ SAFE (not rendered in HTML)

Test 4: Open redirect
- URL: /auth/signin?callbackUrl=https://evil.com
- Expected: Should redirect to evil.com after login
- Verdict: ❌ VULNERABLE

Observations:
- The codebase follows modern secure development practices
- Zod + Prisma + React provide defense in depth against injection attacks
- One open redirect vulnerability needs to be addressed
- No evidence of XSS or SQL injection vulnerabilities

Verdict: FAIL (Open redirect vulnerability in signin page needs to be fixed before production. All XSS and SQL injection protections are in place and working correctly.)
================================================================================

================================================================================
Test: TIER-001 - Free tier users cannot access premium features
Date: 2026-01-05T15:30:00Z
Status: FAIL
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/lib/auth.ts - isPremiumUser() checks user.role === 'premium'
- apps/web/src/server/api/trpc.ts - premiumProcedure defined but NEVER USED anywhere
- apps/web/src/server/api/routers/plan.ts - Uses protectedProcedure only
- apps/web/src/server/services/planGenerator.ts - Has server-side role check for days limit
- apps/web/src/server/api/routers/shoppingList.ts - Returns price data to all users
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Frontend-only days restriction
- apps/web/src/components/features/shopping/ShoppingList.tsx - Frontend-only premium label
- apps/web/src/app/_components/dashboard/PremiumFeatureCard.tsx - UI shows lock icon

Code Issues Found:

ISSUE 1: CRITICAL - premiumProcedure is NEVER USED
- File: apps/web/src/server/api/trpc.ts:146-162
- premiumProcedure middleware is defined but NO router uses it
- All premium features are protected only on the frontend
- This means premium features can be accessed via direct API calls

ISSUE 2: CRITICAL - Price Comparison Data Available to All Users
- File: apps/web/src/server/api/routers/shoppingList.ts:150-180
- The getForMealPlan endpoint returns storePrices to ALL authenticated users
- Only the UI hides the data from free users (ShoppingList.tsx:37)
- Any user can call the tRPC endpoint directly and get price comparison data
- FIX NEEDED: Either use premiumProcedure or conditionally return storePrices based on role

ISSUE 3: PARTIAL - Meal Plan Days Restriction
- File: apps/web/src/server/services/planGenerator.ts:84-92
- Server-side validation EXISTS for days limit (maxDays = 3 for non-premium)
- However, error returns generic Error, not TRPCError with proper code
- UI correctly disables 4-7 day options for free users (MealPlanWizard.tsx:432-438)
- Server correctly rejects requests exceeding limit
- VERDICT: This specific restriction WORKS correctly

ISSUE 4: MEDIUM - "Advanced Customization" Not Actually Premium-Gated
- The advanced filters (difficulty, maxTotalTime, allergens) in MealPlanWizard
- Are NOT marked as premium-only in any way
- If "advanced customization" is meant to be premium, it's not restricted

Summary of Premium Feature Implementation:

| Feature                      | Frontend Gate | Server Gate | Status      |
|------------------------------|---------------|-------------|-------------|
| Days > 3 in meal plan        | ✅ Disabled   | ✅ Validated | WORKING     |
| Price comparison data        | ✅ Hidden     | ❌ Exposed   | BROKEN      |
| Nutritional requirements     | Shows lock    | Not implemented | N/A     |
| Pantry-aware substitutions   | Shows lock    | Not implemented | N/A     |
| Advanced filters             | No restriction| No restriction | N/A      |

Observations:
- The premiumProcedure was created but never integrated into any router
- The frontend uses isPremiumUser() to conditionally show/hide UI elements
- But the API returns data to anyone who is authenticated
- A malicious user could easily access premium data by calling the tRPC API directly
- The dashboard correctly shows "In development" for premium users and lock icons for free users

Verdict: FAIL

The test fails because:
1. Price comparison data is exposed to all authenticated users at the API level
2. The premiumProcedure middleware is never used, so no API endpoint requires premium access
3. Only the days restriction is properly enforced server-side

Recommended Fixes:
1. Use premiumProcedure for endpoints that should be premium-only
2. Or conditionally return sensitive data based on user role in the endpoint
3. Consider creating a separate endpoint for price comparison that uses premiumProcedure

================================================================================

================================================================================
Test: TIER-002 - Premium tier users have full access
Date: 2026-01-05T16:00:00Z
Status: FAIL
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/dashboard/_components/DashboardClient.tsx - Dashboard shows premium features section
- apps/web/src/app/_components/dashboard/PremiumFeatureCard.tsx - Shows "In development" for premium users
- apps/web/src/components/features/shopping/ShoppingList.tsx - isPremiumUser check at line 37
- apps/web/src/app/plan/[id]/page.tsx - ShoppingList rendered without onComparePrices prop
- apps/web/src/server/api/routers/shoppingList.ts - Returns storePrices data to all authenticated users
- apps/web/src/server/api/trpc.ts - premiumProcedure defined but never used
- apps/web/src/server/services/planGenerator.ts - Days limit correctly enforced server-side (premium gets 7 days)
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Premium users can select 4-7 days

Test Step Analysis:

Step 1: "Sign in as premium user" - PASS (via code review)
- Premium user can authenticate with premium@example.com / P@ssw0rd!
- Session correctly includes user.role = 'premium'

Step 2: "Access price comparison feature" - FAIL
- The ShoppingList component on /plan/[id] page is rendered at line 94 WITHOUT the onComparePrices prop
- Without this prop, the "Compare Prices" button is never rendered (ShoppingList.tsx:290 checks `onComparePrices &&`)
- Even though the API (shoppingList.getForMealPlan) returns storePrices and cheapestStore data, there is NO UI to display it
- The only price comparison UI is in PremiumPreviewModal which shows SAMPLE data and prompts to upgrade

Step 3: "Verify full data is displayed" - FAIL
- Price comparison data is NOT displayed anywhere in the premium user experience
- The dashboard shows premium features with "In development" badge (PremiumFeatureCard.tsx:53-59)
- Even the button label says "Compare Prices" but it's never rendered

Step 4: "Access all advanced features" - PARTIAL PASS
- Days restriction: WORKING - Premium users can select 4-7 day plans in MealPlanWizard
- Advanced filters (difficulty, maxTotalTime, allergens): Available to all users (not premium-gated)
- Price comparison: NOT WORKING - UI not implemented
- Nutritional requirements: NOT IMPLEMENTED (shows "In development" badge)
- Pantry-aware substitutions: NOT IMPLEMENTED (shows "In development" badge)

Step 5: "Verify no upgrade prompts for premium features" - PARTIAL PASS
- Dashboard correctly shows "In development" instead of upgrade prompts for premium users
- No "Go Premium" buttons shown to premium users in PremiumFeatureCard

Premium Feature Status Summary:

| Feature                      | API Works | UI Works | Premium-Only |
|------------------------------|-----------|----------|--------------|
| 4-7 day meal plans          | ✅ Yes    | ✅ Yes   | ✅ Yes       |
| Price comparison            | ✅ Yes    | ❌ No    | ❌ No (exposed to all) |
| Nutritional requirements    | ❌ No     | ❌ No    | N/A          |
| Pantry-aware substitutions  | ❌ No     | ❌ No    | N/A          |

Code Issues Found:

ISSUE 1: CRITICAL - Price Comparison UI Not Implemented for Premium Users
- File: apps/web/src/app/plan/[id]/page.tsx:94
- ShoppingList is rendered: `<ShoppingList planId={id} />`
- Missing: `onComparePrices` prop that would enable the button
- FIX: Pass onComparePrices callback and create a PriceComparisonModal for premium users

ISSUE 2: CRITICAL - "Compare Prices" Button Never Rendered
- File: apps/web/src/components/features/shopping/ShoppingList.tsx:290-301
- The button only renders if `onComparePrices` prop is truthy
- Since no caller passes this prop, button is never shown to anyone
- FIX: Either wire up the prop or restructure to show prices inline

ISSUE 3: MEDIUM - API Data Not Used
- storePrices and cheapestStore are returned by getForMealPlan endpoint
- But this endpoint isn't called on the plan page (getForPlan is called instead)
- getForPlan doesn't include price data
- FIX: Either use getForMealPlan or add price data to getForPlan

ISSUE 4: LOW - Premium Features Still "In Development"
- PremiumFeatureCard shows "In development" badge for premium users
- This is accurate since the features aren't actually working
- Not a bug, just indicates features are incomplete

Observations:
- The premium days restriction (4-7 days) is the ONLY fully functional premium feature
- Price comparison backend exists and works, but UI integration is completely missing
- Premium users see "In development" badges which is honest but poor UX for paying customers
- The premium value proposition is severely undermined by non-functional features

Verdict: FAIL

The test fails because:
1. Price comparison feature is NOT accessible to premium users - no UI exists to display the data
2. Advanced features beyond days restriction are either not implemented or not premium-gated
3. Premium users would have a disappointing experience seeing "In development" on features they paid for

Recommended Fixes for Production Readiness:
1. Wire up price comparison: Pass onComparePrices to ShoppingList and create real price display UI
2. Either implement the other premium features or remove them from marketing
3. Use the getForMealPlan endpoint that actually returns price data
4. Add a real PriceComparisonView component that shows actual store prices (not just sample data)
================================================================================

================================================================================
Test: TIER-003 - Admin users can access admin features
Date: 2026-01-05T16:30:00Z
Status: PASS
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/app/dashboard/admin/images/page.tsx - Admin page server component
- apps/web/src/app/dashboard/admin/images/_components/AdminImageGeneratorClient.tsx - Client component for image generation
- apps/web/src/server/api/routers/adminImage.ts - tRPC router for admin image operations
- apps/web/src/server/api/trpc.ts - Contains adminProcedure middleware definition
- apps/web/src/server/api/root.ts - Routes adminImage to appRouter
- apps/web/src/app/dashboard/_components/DashboardClient.tsx - Dashboard shows admin link only to admins

Test Step Analysis:

Step 1: "Sign in as admin user" - PASS (via code review)
- Admin user can authenticate with admin@example.com / P@ssw0rd!
- Session correctly includes user.role = 'admin'

Step 2: "Navigate to /dashboard/admin/images" - PASS
- File: apps/web/src/app/dashboard/admin/images/page.tsx
- Line 11-12: Checks for authentication, redirects to signin if not logged in
- Line 15-17: Checks for admin role, redirects to /dashboard if user is not admin
- The page properly gates access at the server component level

Step 3: "Verify admin page loads" - PASS
- AdminImageGeneratorClient component renders with proper UI
- Shows "Admin only" badge (line 70-73)
- Displays "Nano Banana Pro" badge and image generation form
- Lists recent generated images from database

Step 4: "Verify image generation controls work" - PASS (via code review)
- The form includes:
  - Prompt textarea (line 95-108)
  - Model selection: Nano Banana Pro / Nano Banana (line 17-20, 113-129)
  - Aspect ratio selection: 1:1, 16:9, 4:5 (line 11-15, 131-150)
  - Generate button with loading state (line 162-179)
- API endpoint: adminImage.generate (line 45, 92)
- Router uses adminProcedure which validates admin role (adminImage.ts line 43)
- On success, invalidates list cache and prepends new image (line 46-51)

Step 5: "Verify non-admin users cannot access this page" - PASS (via code review)

Frontend Protection (page.tsx):
- Line 11-13: Unauthenticated users → redirect to /auth/signin
- Line 15-17: Non-admin users → redirect to /dashboard
- This is a SERVER component, so these checks run on the server before any HTML is sent

API Protection (adminImage.ts + trpc.ts):
- Both list (line 15) and generate (line 43) use adminProcedure
- adminProcedure (trpc.ts:167-182) validates:
  1. User is authenticated (throws UNAUTHORIZED if not)
  2. User role === 'admin' (throws FORBIDDEN if not)
- Even if someone bypasses the frontend, API calls will fail

Dashboard Link Visibility:
- DashboardClient.tsx line 136-149 shows admin link ONLY to admin users
- isAdminUser = user.role === 'admin' (line 129)
- Non-admins see only QUICK_ACTIONS without admin link

Code Quality Assessment:

STRENGTHS:
1. Defense in depth - Both page-level and API-level protection
2. Server-side redirect in RSC - No flash of unauthorized content
3. adminProcedure reusable - Easy to add more admin routes
4. Clear UI indication - "Admin only" badge makes role clear
5. Proper error handling - TRPCError with appropriate codes

MINOR OBSERVATIONS (not blocking):
1. Line 36 (DashboardClient): Admin link only appears for 'admin' role, not for premium users
   - This is correct behavior if admin and premium are separate tiers
2. The isGeminiConfigured() check allows page to load but disables form if API key missing
   - Good UX: Admin sees what features exist even without config

Security Verification:
- Direct URL access by non-admin: BLOCKED (server redirect)
- Direct API call by non-admin: BLOCKED (adminProcedure throws FORBIDDEN)
- Direct API call without auth: BLOCKED (adminProcedure throws UNAUTHORIZED)

Verdict: PASS

The test passes because:
1. Admin users CAN access /dashboard/admin/images successfully
2. The admin page loads with full functionality (form, model selection, aspect ratio)
3. Image generation controls are properly wired to adminImage.generate tRPC endpoint
4. Non-admin users are properly blocked at both frontend (redirect) and API (FORBIDDEN) levels
5. Unauthenticated users are redirected to sign-in with callback URL

The admin features implementation is solid with proper authorization at multiple layers.
================================================================================

================================================================================
Test: DATA-001 - User preferences persist across sessions
Date: 2026-01-05T17:00:00Z
Status: FAIL
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/api/routers/preferences.ts - tRPC router for user preferences (get/update)
- apps/web/src/server/api/routers/preferences.test.ts - Tests for preferences router
- apps/web/src/server/api/root.ts - Confirms preferences router is exposed
- apps/web/prisma/schema.prisma - UserPreferences model definition (lines 132-144)
- apps/web/src/components/features/meal-plan/MealPlanWizard.tsx - Wizard component
- apps/web/src/app/planner/page.tsx - Planner page that uses wizard

Test Step Analysis:

Step 1: "Sign in and set preferences" - PARTIAL FAIL
- The backend has a working preferences API:
  - preferences.get (line 6-24) - Returns user preferences or defaults
  - preferences.update (line 27-49) - Upserts preferences with validation
- Database model exists: UserPreferences (schema.prisma:132-144)
- PROBLEM: There is NO UI to set preferences!
  - No settings page exists
  - MealPlanWizard does NOT call preferences.update after form submission
  - The wizard only passes preferences to plan.generate, it doesn't save them

Step 2: "Sign out" - N/A (cannot set preferences to begin with)

Step 3: "Sign back in" - N/A

Step 4: "Verify preferences are restored" - FAIL
- MealPlanWizard.tsx lines 53-65: Uses LOCAL state with hardcoded defaults
  - householdSize defaults to 2
  - mealsPerDay defaults to 1
  - days defaults to isPremium ? 7 : 3
  - isVegetarian/isDairyFree default to false
- NO call to api.preferences.get() to load saved preferences
- User preferences from database are NEVER loaded into the wizard

Step 5: "Verify preferences apply to new meal plans" - FAIL
- Since preferences aren't loaded, they can't apply to new meal plans

Code Issues Found:
1. CRITICAL: No UI exists to save preferences - preferences.update is never called from frontend
2. CRITICAL: MealPlanWizard doesn't load saved preferences - no call to preferences.get
3. Preferences are passed to plan.generate but NOT persisted for future sessions
4. The entire preferences router (get/update) is unused by the frontend
5. Backend is fully functional but frontend integration is missing

Missing Implementation:
1. MealPlanWizard should:
   - Accept initial preferences as props OR fetch them via useQuery
   - Load saved preferences on mount
   - Update state to reflect saved preferences
   - Optionally save preferences when generating (or have explicit "save defaults" button)

2. Either add a dedicated Settings/Preferences page, OR:
   - Modify wizard to save preferences after successful plan generation

Grep verification - No frontend usage of preferences API:
```
$ grep "preferences\.get\|api\.preferences" apps/web/src/**/*.tsx
(no matches found)
```

Backend API Analysis:
- preferences.get: Returns UserPreferences or defaults (works correctly per tests)
- preferences.update: Validates and upserts with proper Zod schema
- Both protected by protectedProcedure (requires auth)

Database Schema (working):
```prisma
model UserPreferences {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(...)
  householdSize Int      @default(2)
  mealsPerDay   Int      @default(1)
  days          Int      @default(7)
  isVegetarian  Boolean  @default(false)
  isDairyFree   Boolean  @default(false)
  dislikes      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}
```

Recommended Fixes for Production Readiness:
1. Modify MealPlanWizard to accept optional initialPreferences prop
2. In planner/page.tsx, fetch preferences via api.preferences.get.useQuery()
3. Pass loaded preferences to MealPlanWizard as initialPreferences
4. After successful plan generation, save preferences via api.preferences.update.useMutation()
5. Consider adding a "Remember these settings" checkbox in the wizard

Example fix for planner/page.tsx:
```tsx
const { data: savedPreferences, isLoading } = api.preferences.get.useQuery();
const updatePreferences = api.preferences.update.useMutation();

// Pass to wizard
<MealPlanWizard 
  initialPreferences={savedPreferences} 
  onComplete={(prefs) => {
    updatePreferences.mutate(prefs); // Save for next time
    generatePlan.mutate({...prefs}); // Generate plan
  }}
/>
```

Verdict: FAIL

The test fails because:
1. There is no way for users to save preferences - no UI exists
2. The MealPlanWizard doesn't load previously saved preferences
3. The preferences API exists and is fully functional but completely unused
4. Each time a user visits /planner, they start with default values
5. User preferences do NOT persist across sessions

This is a significant UX gap - the backend infrastructure exists but frontend integration is missing.
================================================================================

================================================================================
Test: DATA-002 - Meal plan history is preserved
Date: 2026-01-05T15:42:00Z
Status: REVIEWED
--------------------------------------------------------------------------------
Files Reviewed:
- apps/web/src/server/api/routers/plan.ts - Contains `list` (lines 192-200) and `getLast` (lines 157-190) endpoints
- apps/web/src/server/api/routers/mealPlan.ts - Contains `getCurrent` endpoint (lines 91-114)
- apps/web/src/app/planner/last/page.tsx - Redirects to last plan via `/plan/[id]`
- apps/web/src/app/plan/[id]/page.tsx - Plan view page with proper auth and 404 handling
- apps/web/src/app/dashboard/page.tsx - Dashboard calls mealPlan.getCurrent for boolean check
- apps/web/src/app/dashboard/_components/DashboardClient.tsx - UI only shows hasMealPlan flag

Test Step Analysis:

Step 1: "Generate multiple meal plans" - PASS (backend)
- plan.generate mutation creates new MealPlan records
- Plans stored in database with userId association
- Each generation creates a new plan (doesn't overwrite)

Step 2: "Navigate to dashboard" - PARTIAL
- Dashboard renders but only shows binary hasMealPlan flag
- No list of previous plans displayed
- DashboardClient receives `hasMealPlan: !!mealPlan` not plan array

Step 3: "Verify previous plans are accessible" - FAIL
- Backend API exists: plan.list returns last 10 plans with createdAt desc ordering
- BUT frontend never calls plan.list - no UI to browse plan history
- Grep for "plan.list" in *.tsx files: NO MATCHES
- Users cannot see or navigate to old plans from dashboard

Step 4: "Verify /planner/last shows most recent plan" - PASS
- planner/last/page.tsx calls api.plan.getLast()
- Properly redirects to /plan/[id] if plan exists
- Redirects to /planner if no plans exist
- Includes full items with recipes, ingredients, diet/allergen tags

Step 5: "Verify old plans can be viewed" - PARTIAL PASS
- Individual plan pages work: /plan/[id] fetches and displays correctly
- Auth check: plan.userId must match session user
- PROBLEM: No way to discover old plan IDs - no history UI exists

Code Issues Found:
1. CRITICAL: Dashboard does not display plan history
   - DashboardClient.tsx receives boolean hasMealPlan, not plan array
   - No UI component exists to show previous plans
   
2. CRITICAL: plan.list API is unused
   - plan.ts:192-200 defines list endpoint returning last 10 plans
   - Zero frontend components call this API
   - Grep confirms: no "plan.list" usage in any .tsx file

3. Missing feature: "View Plan History" or similar navigation
   - Dashboard Quick Actions only link to /planner (new plan)
   - No way for users to browse their past meal plans
   - The "View last plan" button links to /planner not /planner/last

4. UX Gap: Old plans are inaccessible without knowing IDs
   - Users would need to manually type /plan/[uuid] to view old plans
   - This effectively means old plans are lost to users

Backend Verification (API is correctly implemented):
```
plan.list: 
  - Returns findMany with userId filter
  - Orders by createdAt desc
  - Takes 10 most recent
  - Returns minimal plan objects (no items)

plan.getLast:
  - Returns findFirst with userId filter
  - Orders by createdAt desc
  - Includes full items with recipes
```

Recommended Fixes for Production:
1. Add "Plan History" section to dashboard showing recent plans
2. Use plan.list API to fetch and display plan cards
3. Each card should show: start date, days, meal count, link to /plan/[id]
4. Fix "View last plan" button to link to /planner/last (currently links to /planner)
5. Consider pagination if users generate many plans

Verdict: FAIL

The test fails because:
1. Dashboard does NOT show previous plans - missing UI entirely
2. The plan.list API exists but is completely unused by frontend
3. Users have no way to browse or access their plan history
4. Old plans are only accessible if user knows the UUID
5. While /planner/last works correctly, there's no history navigation

This is a significant feature gap - the backend fully supports plan history but the frontend provides no way to access it.
================================================================================
